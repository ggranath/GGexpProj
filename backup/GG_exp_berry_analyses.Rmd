---
title: 'The GG experiment: a thinning, N, P experiment along a climatic gradient'
author: "Gustaf Granath"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: pdf_document
---

```{r echo=FALSE, results='hide',message=FALSE}
# weather data
clim <- read.csv("clim_data.csv", stringsAsFactors = FALSE)

#subset
clim$month.sing <- as.numeric(substr(clim$month, 6,7))
clim$year.sing <- as.numeric(substr(clim$month, 1,4))
sub.dat <- clim[clim$year.sing > 1969,]

sub.dat.sum <- sub.dat[sub.dat$month.sing > 4 & sub.dat$month.sing < 8,]

#precip 
sub.year <- with(sub.dat.sum[!(is.na(sub.dat.sum$precipitation)),],
     table(year.sing, Stationsnamn))
# most have 3 or 0 onths so no subsetting needed

y.prec <- aggregate(precipitation ~ year.sing + Stationsnamn, sub.dat.sum, sum)
ggplot(data=y.prec, aes(y=precipitation, x=year.sing, color=Stationsnamn)) +
  geom_point()+
  geom_line()+
  geom_point(data=y.prec[y.prec$year.sing > 2013 & y.prec$year.sing < 2016,], 
             aes(y=precipitation, x=year.sing, color=Stationsnamn), color="black")
mean.prec <- mean(y.prec$precipitation, na.rm = TRUE)
mean.prec.2014 <- mean(y.prec[y.prec$year.sing == 2014, "precipitation"], na.rm = TRUE)
mean.prec.2015 <- mean(y.prec[y.prec$year.sing == 2015, "precipitation"], na.rm = TRUE)
# mean = 188 mm
# 2014 = 175 mm
# 2015 = 269 mm

#temp. Only years where all sites have all 3 months
sub.year <- with(sub.dat.sum[!(is.na(sub.dat.sum$air_temp)),],
     table(year.sing, Stationsnamn))
yrs <- apply(sub.year, 1, function (x) sum(x)==21)
yrs <- yrs[yrs==TRUE]
sub.dat.sum.temp <- sub.dat.sum[sub.dat.sum$year.sing %in% as.numeric(names(yrs)),]
y.temp <- aggregate(air_temp ~ year.sing + Stationsnamn, sub.dat.sum.temp, mean)
ggplot(data=y.temp, aes(y=air_temp, x=year.sing, color=Stationsnamn)) +
  geom_point()+
  geom_line()+
  geom_point(data=y.temp[y.temp$year.sing > 2013 & y.temp$year.sing < 2016,], 
             aes(y=air_temp , x=year.sing, color=Stationsnamn), color="black")
per.site.temp <- mean(aggregate(air_temp ~ Stationsnamn, sub.dat.sum.temp, mean)$air_temp)
mean.temp <- mean(y.temp$air_temp, na.rm = TRUE)
mean.temp.2014 <- mean(y.temp[y.temp$year.sing == 2014, "air_temp"], na.rm = TRUE)
mean.temp.2015 <- mean(y.temp[y.temp$year.sing == 2015, "air_temp"], na.rm = TRUE)
# mean temp c. 12.6 C
# 2014 = 13.5
# 2015 = 11.0

# weather done

#Organize the data so we get the righ treatments and some add-on info like latitud.
dat <- read.csv("GG_exp_2014_2015.csv")
dat <- read.csv("gg_soil_depths.csv")
#dat <- read.csv("tea_decomp.csv")
dat <- read.csv("tea_decomp_and_soil_chem.csv")

tre <- read.csv("gg_treat_table.csv")
#treat <- unique(dat[, c("no_exp", "plot", "region", "treatment")])
#full_dat <- (merge(datD, treat, by = c("no_exp", "plot") ))
#write.csv(full_dat, file="decomp.csv")

info <- read.csv("GG_meta.csv")
info <- info[, c("no_exp", "Landskap", "Anl채ggnings책r", "Latitud", "Longitud", "Experiment_namn")]
dat$region <- ifelse(dat$region == "A" | dat$region == "B", "AB", "CD")
#Grang채rde has a different treatment: Severe thinning + N. We can remove it or merge it with
# normal thinning.
#full_dat2 <- full_dat[!(full_dat$real_treat == "severe_thinning+N"),]
#full_dat2 <- droplevels(full_dat2)
dat$treatment[dat$treatment=="L"] <- "F" #Change severe thinning to thinning
dat <- droplevels(dat)

full_dat <- (merge(dat, tre, by = c("region", "treatment") ))
full_dat <- (merge(full_dat, info, by = c("no_exp") ))
full_dat <- droplevels(full_dat)

# If we use raw data for modelling (poisson) #
full_dat$thin <- ifelse(grepl("thinning", full_dat$real_treat), "thin", "no_thin")
full_dat$N <- ifelse(grepl("N", full_dat$real_treat), "Nxtra", "no_N")
full_dat$P <- ifelse(grepl("P", full_dat$real_treat), "Pxtra", "no_P")
full_dat$id <- factor(paste(full_dat$exp_name, full_dat$real_treat, sep = "_" ) ) #make id for the repeated measurement structure.
#full_dat$idd <- factor(paste(full_dat$year, full_dat$exp_name, full_dat$real_treat, sep = "_" ) ) #make id for the repeated measurement structure.
#full_dat$iddd <- factor(1:nrow(full_dat))
full_dat$year <- factor(full_dat$year) # years as categories
full_dat$Latitud.s <- scale(full_dat$Latitud, scale = FALSE) # centralize latitude so means are given for mean latitude (so mid sweden)


###FIRST STOP HERE

# tea decomposition
full_dat$green <- (full_dat$Green..g. - full_dat$after_green)/full_dat$Green..g.
full_dat$red <- (full_dat$Red..g. - full_dat$after_red)/full_dat$Red..g.
#nbh <- full_dat[!(full_dat$comment_g == "vbh" | full_dat$comment_g == "destroyed"), "green" ]
#bh <- full_dat[(full_dat$comment_g == "vbh" | full_dat$comment_g == "destroyed"), "green" ]
#hist(nbh)
#hist(bh)
#mean(nbh, na.rm = TRUE)
#mean(bh, na.rm = TRUE)
#nbh <- full_dat[!(full_dat$comment_r == "vbh" | full_dat$comment_r == "destroyed"), "red" ]
#bh <- full_dat[(full_dat$comment_r == "vbh" | full_dat$comment_r == "destroyed"), "green" ]
#hist(nbh)
#hist(bh)
#mean(nbh, na.rm = TRUE)
#mean(bh, na.rm = TRUE)
# Red tea affected by "holes"
full_dat[full_dat$comment_r == "vbh" | full_dat$comment_r == "destroyed", "red" ] <- NA
full_dat[full_dat$comment_r == "vbh" | full_dat$comment_r == "destroyed", "green" ] <- NA

# decomp green
site_means <- aggregate(green ~ no_exp + real_treat, full_dat, mean)
site_means$no_exp <- factor(site_means$no_exp)
site_means <- (merge(site_means, info[, c("no_exp", "Latitud", "Experiment_namn")], by = c("no_exp") )) #add latitude
treat_means <- aggregate(green ~ real_treat, site_means, mean)
treat_means$se <- aggregate(green ~ real_treat, site_means, FUN = function(x) sd(x)/sqrt(length(x)) )$green
library(ggplot2)
ggplot(treat_means, aes(x=real_treat, y=green)) + 
     geom_errorbar(aes(ymin=green-se, ymax=green+se), width=.01) +
     geom_line() +
     geom_point() +
     theme(axis.text=element_text(size=12)) +
    ylab("")
     geom_line(data = site_means, aes(group=no_exp, colour=no_exp))+
     geom_point(data = site_means, aes(group=no_exp, colour=no_exp))

  #stats green
library(nlme)
site_means$Latitud.s <- scale(site_means$Latitud, scale = FALSE)
mod <- lme(green ~ real_treat + Latitud.s, weights = varComb(varIdent(form = ~ 1|real_treat) ), random = ~1|factor(no_exp), site_means)
anova(mod)
summary(mod)
library(lsmeans)
lsplot.min <- summary(lsmeans(mod, ~ real_treat, at = list(Latitud.s = min(site_means$Latitud.s))))
lsplot.max <- summary(lsmeans(mod, ~ real_treat, at = list(Latitud.s = max(site_means$Latitud.s))))
lsplot <- data.frame(rbind(lsplot.min, lsplot.max), region = rep(c("s.swe", "n.swe"), each =5))
ggplot(lsplot, aes(x=real_treat, y=lsmean, group = region, color = region)) + 
     geom_errorbar(aes(ymin=lsmean-SE, ymax=lsmean+SE), width=.01) +
     geom_line() +
     geom_point() +
     theme(axis.text=element_text(size=12), 
           axis.title=element_text(size=15),
           legend.title=element_text(size=14),
           legend.text = element_text(size = 14) )+
  scale_colour_discrete(name="GREEN TEA\n\nRegion", guide = guide_legend(reverse=TRUE)) +
    ylab("Proportion mass loss") +
    xlab("Treatment")

library(multcomp)
summary(glht(mod, linfct = mcp(real_treat = "Tukey")))

     # decomp red
site_means <- aggregate(red ~ no_exp + real_treat, full_dat, mean)
site_means$no_exp <- factor(site_means$no_exp)
site_means <- (merge(site_means, info[, c("no_exp", "Latitud", "Experiment_namn")], by = c("no_exp") )) #add latitude
treat_means <- aggregate(red ~ real_treat, site_means, mean)
treat_means$se <- aggregate(red ~ real_treat, site_means, FUN = function(x) sd(x)/sqrt(length(x)) )$red
library(ggplot2)
ggplot(treat_means, aes(x=real_treat, y=red)) + 
     geom_errorbar(aes(ymin=red-se, ymax=red+se), width=.01) +
     geom_line() +
     geom_point() +
     theme(axis.text=element_text(size=12))+
     geom_line(data = site_means, aes(group=no_exp, colour=no_exp))+
     geom_point(data = site_means, aes(group=no_exp, colour=no_exp))
library(lattice)
xyplot(red~real_treat|no_exp, site_means, type = c("p"))

  #stats red
library(nlme)
site_means$Latitud.s <- scale(site_means$Latitud, scale = FALSE)
mod <- lme(red ~ real_treat+Latitud.s, weights = varComb(varIdent(form = ~ 1|real_treat), varExp(form = ~ red) ), random = ~1|factor(no_exp), site_means)
anova(mod)

summary(mod)
library(lsmeans)
lsplot.min <- summary(lsmeans(mod, ~ real_treat, at = list(Latitud.s = min(site_means$Latitud.s))))
lsplot.max <- summary(lsmeans(mod, ~ real_treat, at = list(Latitud.s = max(site_means$Latitud.s))))
lsplot <- data.frame(rbind(lsplot.min, lsplot.max), region = rep(c("s.swe", "n.swe"), each =5))
ggplot(lsplot, aes(x=real_treat, y=lsmean, group = region, color = region)) + 
     geom_errorbar(aes(ymin=lsmean-SE, ymax=lsmean+SE), width=.01) +
     geom_line() +
     geom_point() +
     theme(axis.text=element_text(size=12), 
           axis.title=element_text(size=15),
           legend.title=element_text(size=14),
           legend.text = element_text(size = 14) )+
  scale_colour_discrete(name="RED TEA\n\nRegion", guide = guide_legend(reverse=TRUE)) +
    ylab("Proportion mass loss") +
    xlab("Treatment")

library(multcomp)
summary(glht(mod, linfct = mcp(real_treat = "Tukey")))


# soil chem ####
# N
site_means <- aggregate(N_percent ~ no_exp + real_treat, full_dat, mean)
site_means$no_exp <- factor(site_means$no_exp)
site_means <- (merge(site_means, info[, c("no_exp", "Latitud", "Experiment_namn")], by = c("no_exp") )) #add latitude
treat_means <- aggregate(N_percent ~ real_treat, site_means, mean)
treat_means$se <- aggregate(N_percent ~ real_treat, site_means, FUN = function(x) sd(x)/sqrt(length(x)) )$N_percent
library(ggplot2)
ggplot(treat_means, aes(x=real_treat, y=N_percent)) + 
     geom_errorbar(aes(ymin=N_percent-se, ymax=N_percent+se), width=.01) +
     geom_line() +
     geom_point() +
     theme(axis.text=element_text(size=14))

# Mangan
site_means <- aggregate(Mn_mg_kg ~ no_exp + real_treat, full_dat, mean)
site_means$no_exp <- factor(site_means$no_exp)
site_means <- (merge(site_means, info[, c("no_exp", "Latitud", "Experiment_namn")], by = c("no_exp") )) #add latitude
treat_means <- aggregate(Mn_mg_kg ~ real_treat, site_means, mean)
treat_means$se <- aggregate(Mn_mg_kg ~ real_treat, site_means, FUN = function(x) sd(x)/sqrt(length(x)) )$Mn_mg_kg
library(ggplot2)
ggplot(treat_means, aes(x=real_treat, y=Mn_mg_kg)) + 
     geom_errorbar(aes(ymin=Mn_mg_kg-se, ymax=Mn_mg_kg+se), width=.01) +
     geom_line() +
     geom_point() +
     theme(axis.text=element_text(size=14))

library(ggplot2)
ggplot(full_dat, aes(x=Cu_mg_kg, y=C_percent)) +
     geom_smooth(method="lm") +
     geom_point() +
     theme(axis.text=element_text(size=14)) +
  facet_wrap(~Site)

# C:N
full_dat$cn <- full_dat$C_percent/full_dat$N_percent
site_means <- aggregate(cn ~ no_exp + real_treat, full_dat, mean)
site_means$no_exp <- factor(site_means$no_exp)
site_means <- (merge(site_means, info[, c("no_exp", "Latitud", "Experiment_namn")], by = c("no_exp") )) #add latitude
treat_means <- aggregate(cn ~ real_treat, site_means, mean)
treat_means$se <- aggregate(cn ~ real_treat, site_means, FUN = function(x) sd(x)/sqrt(length(x)) )$cn
library(ggplot2)
ggplot(treat_means, aes(x=real_treat, y=cn)) + 
     geom_errorbar(aes(ymin=cn-se, ymax=cn+se), width=.01) +
     geom_line() +
     geom_point() +
     theme(axis.text=element_text(size=14))

# N:P
full_dat$np <- full_dat$N_percent/full_dat$P_mg_kg
site_means <- aggregate(np ~ no_exp + real_treat, full_dat, mean)
site_means$no_exp <- factor(site_means$no_exp)
site_means <- (merge(site_means, info[, c("no_exp", "Latitud", "Experiment_namn")], by = c("no_exp") )) #add latitude
treat_means <- aggregate(np ~ real_treat, site_means, mean)
treat_means$se <- aggregate(np ~ real_treat, site_means, FUN = function(x) sd(x)/sqrt(length(x)) )$np
library(ggplot2)
ggplot(treat_means, aes(x=real_treat, y=np)) + 
     geom_errorbar(aes(ymin=np-se, ymax=np+se), width=.01) +
     geom_line() +
     geom_point() +
     theme(axis.text=element_text(size=14))

ggplot(site_means, aes(x=Latitud, y=np, colour=real_treat)) + 
     geom_point() +
     theme(axis.text=element_text(size=14)) +
     geom_smooth(method="lm", formula = y ~ poly(x, 2), fill=NA)


# soil depth
site_means <- aggregate(SOL_depth_mm ~ no_exp + real_treat, full_dat, mean)
site_means$no_exp <- factor(site_means$no_exp)
site_means <- (merge(site_means, info[, c("no_exp", "Latitud", "Experiment_namn")], by = c("no_exp") )) #add latitude
treat_means <- aggregate(SOL_depth_mm ~ real_treat, site_means, mean)
treat_means$se <- aggregate(SOL_depth_mm ~ real_treat, site_means, FUN = function(x) sd(x)/sqrt(length(x)) )$SOL_depth_mm
library(ggplot2)
ggplot(treat_means, aes(x=real_treat, y=SOL_depth_mm)) + 
     geom_errorbar(aes(ymin=SOL_depth_mm-se, ymax=SOL_depth_mm+se), width=.01) +
     geom_line() +
     geom_point() +
     theme(axis.text=element_text(size=12))
     geom_line(data = site_means, aes(group=no_exp, colour=no_exp))+
     geom_point(data = site_means, aes(group=no_exp, colour=no_exp))

  #stats
summary(lm(SOL_depth_mm ~ factor(no_exp) + real_treat, site_means))
library(nlme)
mod <- lme(SOL_depth_mm ~ real_treat + scale(Latitud, scale=FALSE), weights = varComb(varIdent(form = ~ 1|real_treat) ), random = ~1|factor(no_exp), site_means)
mod <- lme(SOL_depth_mm ~ real_treat + scale(Latitud, scale=FALSE), weights = varExp(0.1,form = ~ SOL_depth_mm), random = ~1|factor(no_exp), site_means, control =  lmeControl(maxIter = 200))

mod <- lme(log(SOL_depth_mm) ~ real_treat + scale(Latitud, scale=FALSE), random = ~1|factor(no_exp), site_means)

summary(mod)
library(multcomp)
summary(glht(mod, linfct = mcp(real_treat = "Tukey")))

#diag
plot(mod, form= resid(., type = "p") ~ fitted(.)| real_treat,id=.15, idLables = site_means$Experiment_namn)
qqnorm(mod, ~ resid(., type = "p") | real_treat, id=.15)

#variances
as.numeric(as.character(VarCorr(mod)[1])) / var(site_means$SOL_depth_mm) #random site
tot.sigm <- mean(mod$sigma*
      coef(mod$modelStruct$varStruct,
          uncons = FALSE, allCoef = TRUE))^2
tot.sigm / var(site_means$SOL_depth_mm) # unexplained

mod$sigma*
      coef(mod$modelStruct$varStruct,
          uncons = FALSE, allCoef = TRUE)



#function for SEs of poisson models
#from Ben Bolkers documents
easyPredCI <- function(model,newdata,alpha=0.05, pred=FALSE) {
    ## baseline prediction, on the linear predictor (logit) scale:
    pred0 <- predict(model,re.form=NA,newdata=newdata)
    ## fixed-effects model matrix for new data
    X <- model.matrix(formula(model,fixed.only=TRUE)[-2],
                   newdata)
    beta <- fixef(model) ## fixed-effects coefficients
    V <- vcov(model)     ## variance-covariance matrix of beta
    if(pred) {pred.se <- sqrt(diag(X %*% V %*% t(X)) + VarCorr(model)$idd[1])} ## std errors of predictions
      else {pred.se <- sqrt(diag(X %*% V %*% t(X)))}
    ## inverse-link (logistic) function: could also use plogis()
    linkinv <- model@resp$family$linkinv
    ## construct 95% Normal CIs on the link scale and
    ##  transform back to the response (probability) scale:
    crit <- -qnorm(alpha/2)
    #for CIs
    #linkinv(cbind(lwr=pred0-crit*pred.se,
     #             upr=pred0+crit*pred.se))
    #for SEs only
    linkinv(cbind(lwr=pred0-pred.se,
                  upr=pred0+pred.se))
}

#function checking overdispersion
overdisp_fun <- function(model) {
  ## number of variance parameters in 
  ##   an n-by-n variance-covariance matrix
  vpars <- function(m) {
    nrow(m)*(nrow(m)+1)/2
  }
  model.df <- sum(sapply(VarCorr(model),vpars))+length(fixef(model))
  rdf <- nrow(model.frame(model))-model.df
  rp <- residuals(model,type="pearson")
  Pearson.chisq <- sum(rp^2)
  prat <- Pearson.chisq/rdf
  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
  c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}
```

```{r}
#Make simple map over sites in sweden ####
# loading the required packages
library(ggplot2)
library(ggmap)

# creating a sample data.frame with your lat/lon points
df <- as.data.frame(cbind(info$Longitud,info$Latitud))

# getting the map
map.gg <- get_map(location = c(lon = mean(df$V1), lat = mean(df$V2)), zoom = 4,
                      maptype = "satellite", scale = 2)

# plotting the map with some points on it
ggg.map <- ggmap(map.gg) +
  geom_point(data = df, aes(x = V1, y = V2, fill = "red", alpha = 0.8), size = 3, shape = 21) +
  guides(fill=FALSE, alpha=FALSE, size=FALSE)
ggsave("gggMap.png")

# save kml file for FEM
library(rgdal)
colnames(info)[6] <- "site_name"
coordinates(info) <- c("Longitud", "Latitud")
proj4string(info) <- CRS("+proj=longlat +datum=WGS84")
writeOGR(info["site_name"], "gg_exp_sites.kml", layer="site_name", driver="KML") 

df <- as.data.frame(cbind(info$Longitud,info$Latitud))
info

# Part 2. means and sums calculations ####
#We start with calculating the means for each site x treatment combination for both years. We also add the treatments as N, thinning and P.

means <- aggregate(cbind(billberry_fruits, billberry_cover, billberry_fungi, billberry_herbivory,
                          cowberry_fruits, cowberry_cover, cowberry_fungi, cowberry_herbivory) ~ 
                      Latitud + region + year + exp_name + real_treat, full_dat, mean)
means$thin <- ifelse(grepl("thinning", means$real_treat), "thin", "no_thin")
means$N <- ifelse(grepl("N", means$real_treat), "Nxtra", "no_N")
means$P <- ifelse(grepl("P", means$real_treat), "Pxtra", "no_P")

means$thin <- ifelse(grepl("thinning", means$real_treat), "thin", "no_thin")
means$N <- ifelse(grepl("N", means$real_treat), "Nxtra", "no_N")
means$P <- ifelse(grepl("P", means$real_treat), "Pxtra", "no_P")

#Or treat fruits as total count
 subd <- full_dat[, c("billberry_fruits", "billberry_fungi", "billberry_herbivory", "billberry_cover",
                          "cowberry_fruits", "cowberry_fungi", "cowberry_herbivory", "cowberry_cover", 
                       "exp_name", "thin", "N", "P", "real_treat", "Latitud", "Longitud","region", "year")]
write.csv(subd, file = "N_thin_exp_Granath_Strengbom_FEM.csv")
 
sums <- aggregate(cbind(billberry_fruits, billberry_fungi, billberry_herbivory, billberry_cover,
                          cowberry_fruits, cowberry_fungi, cowberry_herbivory, cowberry_cover) ~ 
                      Latitud + region + year + exp_name + real_treat, full_dat, sum)
sums$thin <- factor(ifelse(grepl("thinning", sums$real_treat), "thin", "no_thin"))
sums$N <- factor(ifelse(grepl("N", sums$real_treat), "Nxtra", "no_N"))
sums$P <- factor(ifelse(grepl("P", sums$real_treat), "Pxtra", "no_P"))
sums$Latitud.s <- scale(sums$Latitud, scale=FALSE)
#

# General stats
# means
aggregate(cbind(billberry_cover, billberry_fungi, billberry_herbivory,
                          cowberry_cover, cowberry_herbivory) ~
                       year, full_dat, mean)

library(dplyr)
dd <- means %>% 
  group_by(year) %>% 
  summarise_at(vars(billberry_cover, billberry_fungi, billberry_herbivory,
                          cowberry_cover, cowberry_herbivory),
               funs(mean, min, max)) %>%
  as.data.frame()
dd

# per m2
ee <- means %>% 
  group_by(year) %>% 
  summarise_at(vars(billberry_fruits, cowberry_fruits, cowberry_fungi),
               funs(mean, median, min, max)) %>%
  as.data.frame()
ee*4


#Grang채rde has a different treatment: Severe thinning + N. We remove it for to keep it simple.
means <- means[!(means$real_treat == "severe_thinning+N"),]
means <- droplevels(means)

#Overview treatments and sample size
treat.n <- table(means[,c("thin","N", "P")])

### STOP PART 2 ###

```

#Berries
First berry production (billberry and cowberry).
We can plot the results for each site.

```{r,echo = FALSE,fig.width=14, fig.height=10}
library(lattice)
xyplot(billberry_fruits ~ real_treat|exp_name, groups = year, means, main ="Billberry",type = c("p","l"), auto=TRUE, xlab="",
       scales=list( x=list(labels = c("No \nthin", "No \nthin+N", "thin","thin+\nN","thin+\nNP"))))
xyplot(cowberry_fruits ~ real_treat|exp_name, groups = year, sums, main ="Cowberry",type = c("p","l"), auto=TRUE, xlab="",ylim=c(0,100),
       scales=list( x=list(labels = c("No \nthin", "No \nthin+N", "thin","thin+\nN","thin+\nNP"))))
```

Clearly more billberries in 2015, but that doesnt seems to hold up for cowberry. Otherwise trends are not obvious. Seems like thinning has a slight positive effect. Lets put everything in one graph

```{r,echo = FALSE}
xyplot(billberry_fruits ~ real_treat|year, groups = exp_name, means, main ="Billberry", type = c("p","l"), xlab="",
       scales=list( x=list(labels = c("No \nthin", "No \nthin+N", "thin","thin+\nN","thin+\nNP"))))
xyplot(cowberry_fruits ~ real_treat|year, groups = exp_name, means, main ="Cowberry", type = c("p","l"), xlab="",
       scales=list( x=list(labels = c("No \nthin", "No \nthin+N", "thin","thin+\nN","thin+\nNP"))))
```

Ugh! That got messy. Lets see if some stats can sort this out.


Maybe we can pick up that thinning effect in a statistical model?
We may want to skip the "not_thinned+N" treatment since we only have data from a few sites. But lets keep for now.
```{r echo=FALSE, results='hide',message=FALSE}
#remove not_thinned+N
#means <- means[!(means$real_treat=="not_thinned+N"),]
```

Variance increases with the response so we need to deal with that. Im applying a variance function here to model the increasing variance. This is often a good solution since you avoid taking the natural log (not always easy to interpret the results).

##First billberry. ####
```{r echo=FALSE}
library(lme4)
full_dat2 <- full_dat # here you can remove the severe thin+N
sum(full_dat2[full_dat2$billberry_fruits == "0","billberry_cover"] == 0) / length(full_dat2[full_dat2$billberry_fruits == "0","billberry_cover"]) # % of 0 berries that are due to no cover
prior = list(R=list(V=1, nu=0.002), 
             G=list(G1=list(V=1, nu=0.002, alpha.mu=0, alpha.V=625^2), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2),
                    G3=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2))) 

hist(full_dat$cowberry_fruits, breaks=100, xlim=c(0,99))
bill.mc <- MCMCglmm(cowberry_fruits ~ year*N*thin + year*P + Latitud.s, random = ~exp_name + id + idd, data=full_dat, family = "poisson",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(bill.mc)
aggregate(cowberry_fruits ~ year*N*thin+year*P, full_dat, mean)

# PART 3. fruit analyses, aggregated data ####
sums$id <- factor(paste(sums$real_treat,sums$exp_name, sep="_"))

#lmer
# sums$area <- 14*0.25
# sums$idd <- factor(1:nrow(sums))
# set.seed(101)
# library(lme4)
# modB_pois_cat_fru.b11 <- glmer(billberry_fruits ~ Latitud.s + year*N*thin+year*P +  (year|exp_name)+ (1|id) + (1|idd), 
#                                sums, family = poisson)
# overdisp_fun(modB_pois_cat_fru.b)
# summary(modB_pois_cat_fru.b11)
# AIC((modB_pois_cat_fru.b))
# predict(modB_pois_cat_fru.b11, newdata=newDat, re.form=NA, type="response", allow.new.levels=TRUE)
# 
# newDat$means <- predict(modB_pois_cat_fru.b, newDat, re.form=NA, type = "response")
# seLim <- easyPredCI(modB_pois_cat_fru.b, newDat[,-ncol(newDat)], pred=FALSE)
# newDat/14 <- cbind(newDat,seLim)

#raw means
raw.means <- aggregate(billberry_cover ~ year*N*thin+year*P, sums, mean)

# MCMCglmm
library(MCMCglmm)
# First model not controlling for precent cover
#sums2 <- sums[!(sums$exp_name=="929Nysund"),] #if removed an effect of latitude
prior = list( R=list(V=1, nu=0.002), 
             G=list(G1=list(V=diag(2), nu=0.002, alpha.mu=c(0,0), alpha.V=diag(2)*625^2), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2))) 

#sums$thin <- relevel(sums$thin, ref="no_thin") # thinning as reference level instead
bill.mc <- MCMCglmm(billberry_fruits ~ year*N*thin + year*P + Latitud.s, random = ~idh(year):exp_name + id, 
                    data=sums, family = "poisson",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE,
                    saveX = TRUE, saveZ = TRUE,  singular.ok=TRUE )
summary(bill.mc)
# random slope model with covaraince between intercept and slope only 2 DIC smaller 
# so a simpler model without covariance is OK as well.

# Estimate an overall year effect
#sums$year <- relevel(sums$year, ref="2015") # thinning as reference level instead
bill.mc.year <- MCMCglmm(billberry_fruits ~ year + Latitud.s, random = ~idh(year):exp_name + id, 
                    data=sums, family = "poisson",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE,
                    saveX = TRUE, saveZ = TRUE,  singular.ok=TRUE )
summary(bill.mc.year)

# next model we controll for percent plant cover. With the offset term we get fruits per percent cover
B= list(mu = matrix(c(0,0,0,0,0,0,1,0,0,0,0,0),12),V = diag(12)*(10))
prior = list(B=B, R=list(V=1, nu=0.002), 
             G=list(G1=list(V=diag(2), nu=0.002, alpha.mu=c(0,0), alpha.V=diag(2)*1000), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2))) 
diag(prior$B$V)[7]<-1e-9

#sums2 <- sums[!(sums$exp_name=="929Nysund"),] #if removed an effect of latitude
bill.con.mc <- MCMCglmm(billberry_fruits ~ year*N*thin + year*P + Latitud.s + log(billberry_cover), random = ~idh(year):exp_name + id, data=sums, family = "poisson",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior, singular.ok=TRUE )
#modB_pois_cat_fru
summary(bill.con.mc)

#plot effect
# first without offset
raw.means <- aggregate(billberry_fruits ~ year*thin*N+year*P, sums, mean)
newDat <- raw.means[,1:4] 
newDat$Latitud.s <- 0
#newDat$area <- 1 # per m2 if offset for area is in the model
X <- model.matrix(formula(bill.mc$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat)
res <- apply(bill.mc$Sol[,3:11],1, function (x) x %*% t(X[,-c(1:2)]))
raw.means$eff <- rowMeans(res)
cis <- t(apply(res, 1, function (x) HPDinterval(as.mcmc(x))))
raw.means <- cbind(raw.means, cis)
colnames(raw.means)[7:8] <- c("lo_95", "up_95")
lat.eff <- summary(bill.mc)$solutions[6,1:3] #latitude effect
names(lat.eff) <- colnames(raw.means)[6:8]
raw.means <- rbind(raw.means, c(raw.means[10,1:5], lat.eff) )
raw.means$vars <- c("control", "control", "Thin-2014", "Thin-2015", "N-2014", "N-2015",
                    "Thin+N-2014", "Thin+N-2015", "Thin+N+P-2014", "Thin+N+P-2015", "latitude")
raw.means[,6:8] <- (exp(raw.means[,6:8]))

# then with offset
raw.means.off <- aggregate(billberry_fruits ~ year*thin*N+year*P, sums, mean)
newDat.off <- raw.means.off[,1:4] 
newDat.off$Latitud.s <- 0
newDat.off$billberry_cover <- 1 # per m2 if offset for area is in the model
X.off <- model.matrix(formula(bill.con.mc$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat.off)
res.off <- apply(bill.con.mc$Sol[,3:12],1, function (x) x %*% t(X.off[,-c(1:2)]))
raw.means.off$eff <- rowMeans(res.off)
cis.off <- t(apply(res.off, 1, function (x) HPDinterval(as.mcmc(x))))
raw.means.off <- cbind(raw.means.off, cis.off)
colnames(raw.means.off)[7:8] <- c("lo_95", "up_95")
lat.eff.off <- summary(bill.con.mc)$solutions[6,1:3] #latitude effect
names(lat.eff.off) <- colnames(raw.means.off)[6:8]
raw.means.off <- rbind(raw.means.off, c(raw.means.off[10,1:5], lat.eff.off) )
raw.means.off$vars <- c("control", "control", "Thin-2014", "Thin-2015", "N-2014", "N-2015",
                    "Thin+N-2014", "Thin+N-2015", "Thin+N+P-2014", "Thin+N+P-2015", "latitude")
raw.means.off[,6:8] <- (exp(raw.means.off[,6:8]))


library(ggplot2)
bill.p <- ggplot(raw.means[-c(1:2),], aes(x=vars, y=eff)) + 
  geom_hline(yintercept=1, lty=2, lwd=1, colour="grey50") +
  geom_errorbar(aes(ymin=lo_95, ymax=up_95), 
                lwd=0.7, colour="red", width=0, , position=position_nudge(x=0.1)) +
  geom_point(size=2, pch=21, aes(fill="yellow"), position=position_nudge(x=0.1)) +
  geom_point(data=raw.means.off[-c(1:2),], aes(x=vars, y=eff, fill="blue"), position=position_nudge(x=-0.1), 
             size=2, pch=21) +
  geom_errorbar(data=raw.means.off[-c(1:2),], aes(ymin=lo_95, ymax=up_95), 
               lwd=0.7, colour="black", width=0, , position=position_nudge(x=-0.1)) +
  ylim(c(0, 4)) +
  xlab("") +
  ylab("Rate ratio") +
  theme(axis.text.x  = element_text(size=14),
        axis.text.y  = element_text(size=14)) +
  coord_flip() +
  scale_fill_manual(name="Model",values=c("blue", "yellow"), breaks = c("yellow", "blue"), 
                    labels= c("Overall effect", "Controlling for plant cover")) +
  theme(legend.justification=c(1,1), legend.position=c(1,1))
ggsave("bilFig.png", bill.p)  
##### done billberry

### Now cowberry
prior = list(R=list(V=1, nu=0.002), 
             G=list(G1=list(V=diag(1), nu=0.002, alpha.mu=c(0), alpha.V=diag(1)*625^2), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2))) 

cow.mc <- MCMCglmm(cowberry_fruits ~ year*N*thin + year*P + Latitud.s, 
                    random = ~ exp_name + id, data=sums, singular.ok=TRUE, family = "poisson",  nitt = 110000,
                    burnin = 15000, thin=50, pr = TRUE, 
                    pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(cow.mc)
# DIC 6 higher without year-specific variances (random slope model) so not needed

# Overall year effect
cow.mc.year <- MCMCglmm(cowberry_fruits ~ year + Latitud.s, 
                    random = ~ exp_name + id, data=sums, singular.ok=TRUE, family = "poisson",  nitt = 110000,
                    burnin = 15000, thin=50, pr = TRUE, 
                    pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(cow.mc.year)


B= list(mu = matrix(c(0,0,0,0,0,0,1,0,0,0,0,0),12),V = diag(12)*(10))
prior = list(B=B,R=list(V=1, nu=0.002), 
             G=list(G1=list(V=1, nu=0.002, alpha.mu=c(0), alpha.V=diag(1)*625^2), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2))) 
diag(prior$B$V)[7]<-1e-9

cow.con.mc <- MCMCglmm(cowberry_fruits ~ year*N*thin + year*P + Latitud.s + log(cowberry_cover+0.5), 
                    random = ~exp_name + id, data=sums, singular.ok=TRUE, family = "poisson",  nitt = 110000,
                    burnin = 15000, thin=50, pr = TRUE, 
                    pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
# modB_pois_cat_fru
summary(cow.con.mc)

# sums2 <- sums[sums$year == "2014",]
# cow.glmerA <- glmer(cowberry_fruits ~ N + thin*year +  (1|exp_name)+(1|id)+(1|idd), 
#                                sums, family = poisson)
# 
# summary(cow.glmerA)
# plot(resid(cow.glmerA, type='pearson') ~ predict(cow.glmerA, re.form=NA) )
# 
# overdisp_fun(cow.glmer)
# dd <- predict(cow.glmer, type='response', newdata=ss[,1:3], re.form=NA)
# aggregate(dd ~ N+year*thin, sums, mean )
# ss <- aggregate(cowberry_fruits ~ year*N*thin + year*P, sums, mean )
# 
# plot(cow.glmer4, type=c("p"), id = 0.05 )
# plot(cow.glmer4,  factor(exp_name) ~ resid(., type='pearson'),  abline=c(v=0), lty=2)
# plot(cow.glmer, resid(., type='pearson') ~ fitted(.) | factor(exp_name), id = 0.05)
# qqmath(ranef(cow.glmerA, condVar=TRUE))
# dotplot(ranef(cow.glmerA, condVar=TRUE))
# plot(cow.glmerA, sqrt(abs(resid(.))) ~ fitted(.), type=c('p', 'smooth'))
# plot(cow.glmer, resid(.) ~ fitted(.) | exp_name, abline=c(h = 0),  lty = 1,  type = c("p", "smooth")) 

#plot effect
raw.means <- aggregate(cowberry_fruits ~ year*thin*N+year*P, sums, mean)
newDat <- raw.means[,1:4] 
newDat$Latitud.s <- 0
X <- model.matrix(formula(cow.mc$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat)
res <- apply(cow.mc$Sol[,3:11],1, function (x) x %*% t(X[,-c(1:2)]))
raw.means$eff <- rowMeans(res)
cis <- t(apply(res, 1, function (x) HPDinterval(as.mcmc(x))))
raw.means <- cbind(raw.means, cis)
colnames(raw.means)[7:8] <- c("lo_95", "up_95")
lat.eff <- summary(cow.mc)$solutions[6,1:3] #latitude effect
names(lat.eff) <- colnames(raw.means)[6:8]
raw.means <- rbind(raw.means, c(raw.means[10,1:5], lat.eff) )
raw.means$vars <- c("control", "control", "Thin-2014", "Thin-2015", "N-2014", "N-2015",
                    "Thin+N-2014", "Thin+N-2015", "Thin+N+P-2014", "Thin+N+P-2015", "latitude")
raw.means[,6:8] <- raw.means[,6:8]

# then with offset
raw.means.off <- aggregate(cowberry_fruits ~ year*thin*N+year*P, sums, mean)
newDat.off <- raw.means.off[,1:4] 
newDat.off$Latitud.s <- 0
newDat.off$cowberry_cover <- 0.5 # per m2 if offset for area is in the model
X.off <- model.matrix(formula(cow.con.mc$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat.off)
res.off <- apply(cow.con.mc$Sol[,3:12],1, function (x) x %*% t(X.off[,-c(1:2)]))
raw.means.off$eff <- rowMeans(res.off)
cis.off <- t(apply(res.off, 1, function (x) HPDinterval(as.mcmc(x))))
raw.means.off <- cbind(raw.means.off, cis.off)
colnames(raw.means.off)[7:8] <- c("lo_95", "up_95")
lat.eff.off <- summary(cow.con.mc)$solutions[6,1:3] #latitude effect
names(lat.eff.off) <- colnames(raw.means.off)[6:8]
raw.means.off <- rbind(raw.means.off, c(raw.means.off[10,1:5], lat.eff.off) )
raw.means.off$vars <- c("control", "control", "Thin-2014", "Thin-2015", "N-2014", "N-2015",
                    "Thin+N-2014", "Thin+N-2015", "Thin+N+P-2014", "Thin+N+P-2015", "latitude")
raw.means.off[,6:8] <- raw.means.off[,6:8]

library(ggplot2)
cow.p <- ggplot(raw.means[-c(1:2),], aes(x=vars, y=eff)) + 
  geom_hline(yintercept=0, lty=2, lwd=1, colour="grey50") +
  geom_errorbar(aes(ymin=lo_95, ymax=up_95), 
                lwd=0.7, colour="red", width=0, , position=position_nudge(x=0.1)) +
  geom_point(size=2, pch=21, aes(fill="yellow"), position=position_nudge(x=0.1)) +
  geom_point(data=raw.means.off[-c(1:2),], aes(x=vars, y=eff, fill="blue"), position=position_nudge(x=-0.1), 
             size=2, pch=21) +
  geom_errorbar(data=raw.means.off[-c(1:2),], aes(ymin=lo_95, ymax=up_95), 
               lwd=0.7, colour="black", width=0, , position=position_nudge(x=-0.1)) +
  ylim(c(-8, 7)) +
  xlab("") +
  ylab("Log rate ratio") +
  theme(axis.text.x  = element_text(size=14),
        axis.text.y  = element_text(size=14)) +
  coord_flip() +
  scale_fill_manual(name="Model",values=c("blue", "yellow"), breaks = c("yellow", "blue"), 
                    labels= c("Overall effect", "Controlling for plant cover")) +
  theme(legend.justification=c(0,1), legend.position=c(0,1))
ggsave("cowFig.png", cow.p)  

#### done cowberry

# Part 4. plant cover #### 
library(MCMCglmm)
## NO YEAR*TREATMENT INTERACTION
# billberry
sums$id <- factor(paste(sums$real_treat,sums$exp_name, sep="_"))
prior = list(R=list(V=1, nu=0.002), 
             G=list(G1=list(V=diag(2), nu=0.002, alpha.mu=c(0,0), alpha.V=diag(2)*625^2), 
                    G2=list(V=1, nu=1,alpha.mu=0, alpha.V=625^2))) 

sums$billberry_cover2 <- sums$billberry_cover/14
bill.cov.mc <- MCMCglmm(billberry_cover2 ~ year + N*thin + P + Latitud.s, random = ~idh(year):exp_name + id, data=sums, family = "gaussian",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior, singular.ok=TRUE )
summary(bill.cov.mc)
# No treatment effects and very small effect sizes (<5%)

#plot effect
raw.means <- aggregate(billberry_cover ~ year+thin*N+P, sums, mean)
newDat <- raw.means[,1:4] 
newDat$Latitud.s <- 0
X <- model.matrix(formula(bill.cov.mc$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat)
res <- apply(bill.cov.mc$Sol[,3:7],1, function (x) x %*% t(X[,-c(1:2)]))
raw.means$eff <- rowMeans(res)
cis <- t(apply(res, 1, function (x) HPDinterval(as.mcmc(x))))
raw.means <- cbind(raw.means, cis)
colnames(raw.means)[7:8] <- c("lo_95", "up_95")
lat.eff <- summary(bill.cov.mc)$solutions[6,1:3] #latitude effect
names(lat.eff) <- colnames(raw.means)[6:8]
raw.means <- rbind(raw.means, c(raw.means[10,1:5], lat.eff) )
raw.means <- raw.means[c(1,3,5,7,9,11),]
raw.means$vars <- c("control", "Thin","N", "Thin+N", "Thin+N+P", "Latitude")

library(ggplot2)
bill.cov.p <- ggplot(raw.means[-1,], aes(x=vars, y=eff)) + 
  geom_hline(yintercept=0, lty=2, lwd=1, colour="grey50") +
  geom_errorbar(aes(ymin=lo_95, ymax=up_95), 
                lwd=0.7, width=0) +
  geom_point(size=4, pch=21, fill="black") +
  ylim(c(-30, 30)) +
  xlab("") +
  ylab("Absolute change (%)") +
  theme(axis.text.x  = element_text(size=14),
        axis.text.y  = element_text(size=14),
        axis.title = element_text(size=14)) +
  annotate("text", label = "a)", y = -23, x = 5.3, size = 10) +
  coord_flip()

##### done billberry

##Now cowberry
#prior = list(R=list(V=1, nu=0.002), 
#             G=list(G1=list(V=1, nu=0.002, alpha.mu=c(0), alpha.V=diag(1)*625^2), 
#                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2))) 

# values "equally"" spread from 0-100. Gaussian dist not a good option.
# We use negative-binomial instead
library(lme4)
sums$cowberry_cover2 <- sums$cowberry_cover/14
sums$idd <- 1:NROW(sums)
cow.cov.nb <- glmer.nb(cowberry_cover2 ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id), 
                       data=sums)
cow.cov.bin <- glmer(cowberry_cover2/100 ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id) + (1|idd), 
                       data=sums, family = "binomial", weights = rep(100, NROW(sums)),glmerControl(optimizer="bobyqa"))

cow.cov.bin2 <- glmer(cbind(cowberry_cover,1400-cowberry_cover) ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id) + (1|idd), data=sums, family = "binomial", glmerControl(optimizer="bobyqa"))

cow.cov.lm <- lmer(cowberry_cover2 ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id), 
                       data=sums)
cow.cov.lm2 <- lmer(sqrt(cowberry_cover2) ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id), 
                       data=sums)

cow.cov.lmlog <- lmer(cowberry_cover2 ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id), 
                       data=sums)

summary(cow.cov.bin2)

#MCMC version for binomial approach
prior=list(R=list(V=1, nu=0.002), G=list(G1=list(V=1, nu=1, alpha.mu=0, alpha.V=600^2),
                                         G2=list(V=1, nu=1, alpha.mu=0, alpha.V=600^2)))
sums$quad <- 1400
cow.cov.mc2 <- MCMCglmm(cbind(cowberry_cover,quad-cowberry_cover) ~ year*N*thin + year*P + Latitud.s, 
                        random = ~exp_name + id, data=sums, singular.ok=TRUE, family = "multinomial2",  
                        nitt = 110000, burnin = 15000, thin=50, 
                        pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(cow.cov.mc2)
predict(cow.cov.mc2)

#MCMC version for normal errors and transformation.
# Simple so lets us that. Results close to the more "accurate" binomial model which is more
# complicated to interpret and comapre with the billberry model
prior=list(R=list(V=1, nu=0.002), G=list(G1=list(V=1, nu=1, alpha.mu=0, alpha.V=625^2),
                                         G2=list(V=1, nu=1, alpha.mu=0, alpha.V=625^2)))
sums$cowberry_cover2 <- sums$cowberry_cover/14
cow.cov.mc <- MCMCglmm(sqrt(cowberry_cover2) ~ year+N*thin + P + Latitud.s, random = ~exp_name + id, 
                   data=sums, family = "gaussian",  nitt = 110000, burnin = 15000,
                   thin=50, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(cow.cov.mc)
summary(cow.cov.mc2)

#plot effect
raw.means <- aggregate(cowberry_cover2 ~ year+thin*N+P, sums, mean)
newDat <- raw.means[,1:4] 
newDat$Latitud.s <- 0
X <- model.matrix(formula(cow.cov.mc$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat)
res <- apply(cow.cov.mc$Sol[,1:7],1, function (x) x %*% t(X))

# Sqrt tranformed response so for comparison with billberry model (which is untransformed)
# effect sizes are recalculated on the response scale
# Effects are calculated but taking the difference beyween treatment groups
# while contrasts are kept the same
res_eff1 <- (apply(res, 2, function (x) x[c(3,5,7,9)]^2 - x[1]^2 ))
#res_eff2 <- (apply(res, 2, function (x) x[c(4,6,8,10)]^2 - x[2]^2 ))
#res <- rbind(res_eff1, res_eff2)[c(1,5,2,6,3,7,4,8),] 
res <- res_eff1[c(1,2,3,4),] 
#raw.means$eff[1:2] <- 0
raw.means <- raw.means[c(3,5,7,9),]
raw.means$eff <- rowMeans(res)
cis <- t(apply(res, 1, function (x) HPDinterval(as.mcmc(x))))
#cis <- rbind(c(0,0),c(0,0), cis)
raw.means <- cbind(raw.means, cis)
colnames(raw.means)[7:8] <- c("lo_95", "up_95")
lat.eff <- summary(cow.cov.mc)$solutions[6,1:3] #latitude effect
names(lat.eff) <- colnames(raw.means)[6:8]
raw.means <- rbind(raw.means, c(raw.means[10,1:5], lat.eff) )
raw.means$vars <- c("Thin", "N", "Thin+N", "Thin+N+P", "Latitude")
#raw.means[,6:8] <- raw.means[,6:8]

cow.cov.p <- ggplot(raw.means, aes(x=vars, y=eff)) + 
  geom_hline(yintercept=0, lty=2, lwd=1, colour="grey50") +
  geom_errorbar(aes(ymin=lo_95, ymax=up_95), 
                lwd=0.7, width=0) +
  geom_point(size=4, pch=21, fill="black") +
  ylim(c(-30, 30)) +
  xlab("") +
  ylab("Absolute change (%)") +
  theme(axis.text.x  = element_text(size=14),
        axis.text.y  = element_text(size=14),
        axis.title = element_text(size=14)) +
  annotate("text", label = "b)", y = -23, x = 5.3, size = 10) +
  coord_flip()

#### done cowberry

# Merge plots
library(gridExtra)
png("cover_plot_new.png", width=15, height=30, units="cm", res=300)
grid.arrange(bill.cov.p , cow.cov.p , ncol=1, nrow =2)
dev.off()
ggsave("cover_plot.png", width=15, height=30, units="cm", dpi=300)

#### plot effects for neg bin model with glmer
#plot effect
raw.means <- aggregate(cowberry_cover2 ~ year*thin*N+year*P, sums, mean)
newDat <- raw.means[,1:4] 
newDat$Latitud.s <- 0
X <- model.matrix(formula(cow.cov.nb, fixed.only=TRUE)[-2],
                   newDat)
beta <- fixef(cow.cov.nb) ## fixed-effects coefficients
    V <- vcov(cow.cov.nb)[3:11,3:11]     ## variance-covariance matrix of beta
    pred.se <- sqrt(diag(X[,-c(1:2)] %*% V %*% t(X[,-c(1:2)]))) ## std errors of predictions

res <- as.vector(fixef(cow.cov.nb)[3:11] %*% t(X[,-c(1:2)]))
raw.means$eff <- res
cis <- cbind(res - 2*pred.se, res + 2*pred.se)
raw.means <- cbind(raw.means, cis)
colnames(raw.means)[7:8] <- c("lo_95", "up_95")
lat.eff <- summary(cow.cov.nb)$coefficients[6,1:2] #latitude effect
lat.eff <- c(lat.eff[1], lat.eff[1] - lat.eff[2]*2, lat.eff[1] + lat.eff[2]*2)
names(lat.eff) <- colnames(raw.means)[6:8]
raw.means <- rbind(raw.means, c(raw.means[10,1:5], lat.eff) )
raw.means$vars <- c("control", "control", "Thin-2014", "Thin-2015", "N-2014", "N-2015",
                    "Thin+N-2014", "Thin+N-2015", "Thin+N+P-2014", "Thin+N+P-2015", "latitude")




## INCLUDING YEAR*TREATMENT INTERACTION
# billberry
sums$id <- factor(paste(sums$real_treat,sums$exp_name, sep="_"))
library(MCMCglmm)
prior = list(R=list(V=1, nu=0.002), 
             G=list(G1=list(V=diag(2), nu=0.002, alpha.mu=c(0,0), alpha.V=diag(2)*625^2), 
                    G2=list(V=1, nu=1,alpha.mu=0, alpha.V=625^2))) 

sums$billberry_cover2 <- sums$billberry_cover/14
bill.cov.mc <- MCMCglmm(billberry_cover2 ~ year*N*thin + year*P + Latitud.s, random = ~idh(year):exp_name + id, data=sums, family = "gaussian",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior, singular.ok=TRUE )
summary(bill.cov.mc)
# No treatment effects and very small effect sizes (<5%)

#plot effect
raw.means <- aggregate(billberry_cover ~ year*thin*N+year*P, sums, mean)
newDat <- raw.means[,1:4] 
newDat$Latitud.s <- 0
X <- model.matrix(formula(bill.cov.mc$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat)
res <- apply(bill.cov.mc$Sol[,3:11],1, function (x) x %*% t(X[,-c(1:2)]))
raw.means$eff <- rowMeans(res)
cis <- t(apply(res, 1, function (x) HPDinterval(as.mcmc(x))))
raw.means <- cbind(raw.means, cis)
colnames(raw.means)[7:8] <- c("lo_95", "up_95")
lat.eff <- summary(bill.cov.mc)$solutions[6,1:3] #latitude effect
names(lat.eff) <- colnames(raw.means)[6:8]
raw.means <- rbind(raw.means, c(raw.means[10,1:5], lat.eff) )
raw.means$vars <- c("control", "control", "Thin-2014", "Thin-2015", "N-2014", "N-2015",
                    "Thin+N-2014", "Thin+N-2015", "Thin+N+P-2014", "Thin+N+P-2015", "latitude")
raw.means[,6:8] <- raw.means[,6:8]

library(ggplot2)
bill.cov.p <- ggplot(raw.means[-c(1:2),], aes(x=vars, y=eff)) + 
  geom_hline(yintercept=0, lty=2, lwd=1, colour="grey50") +
  geom_errorbar(aes(ymin=lo_95, ymax=up_95), 
                lwd=0.7, width=0) +
  geom_point(size=4, pch=21, fill="black") +
  ylim(c(-25, 25)) +
  xlab("") +
  ylab("Absolute change (%)") +
  theme(axis.text.x  = element_text(size=14),
        axis.text.y  = element_text(size=14),
        axis.title = element_text(size=14)) +
  annotate("text", label = "a)", y = -23, x = 9, size = 10) +
  coord_flip()

##### done billberry

##Now cowberry
#prior = list(R=list(V=1, nu=0.002), 
#             G=list(G1=list(V=1, nu=0.002, alpha.mu=c(0), alpha.V=diag(1)*625^2), 
#                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2))) 

# values "equally"" spread from 0-100. Gaussian dist not a good option.
# We use negative-binomial instead
library(lme4)
sums$cowberry_cover2 <- sums$cowberry_cover/14
sums$idd <- 1:NROW(sums)
cow.cov.nb <- glmer.nb(cowberry_cover2 ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id), 
                       data=sums)
cow.cov.bin <- glmer(cowberry_cover2/100 ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id) + (1|idd), 
                       data=sums, family = "binomial", weights = rep(100, NROW(sums)),glmerControl(optimizer="bobyqa"))

cow.cov.bin2 <- glmer(cbind(cowberry_cover,1400-cowberry_cover) ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id) + (1|idd), data=sums, family = "binomial", glmerControl(optimizer="bobyqa"))

cow.cov.lm <- lmer(cowberry_cover2 ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id), 
                       data=sums)
cow.cov.lm2 <- lmer(sqrt(cowberry_cover2) ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id), 
                       data=sums)

cow.cov.lmlog <- lmer(cowberry_cover2 ~ year*N*thin + year*P + Latitud.s + (1|exp_name) + (1|id), 
                       data=sums)

summary(cow.cov.bin2)

#MCMC version for binomial approach
prior=list(R=list(V=1, nu=0.002), G=list(G1=list(V=1, nu=1, alpha.mu=0, alpha.V=600^2),
                                         G2=list(V=1, nu=1, alpha.mu=0, alpha.V=600^2)))
sums$quad <- 1400
cow.cov.mc2 <- MCMCglmm(cbind(cowberry_cover,quad-cowberry_cover) ~ year*N*thin + year*P + Latitud.s, 
                        random = ~exp_name + id, data=sums, singular.ok=TRUE, family = "multinomial2",  
                        nitt = 110000, burnin = 15000, thin=50, 
                        pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(cow.cov.mc2)
predict(cow.cov.mc2)

#MCMC version for normal errors and transformation.
# Simple so lets us that. Results close to the more "accurate" binomial model which is more
# complicated to interpret and comapre with the billberry model
prior=list(R=list(V=1, nu=0.002), G=list(G1=list(V=1, nu=1, alpha.mu=0, alpha.V=625^2),
                                         G2=list(V=1, nu=1, alpha.mu=0, alpha.V=625^2)))
sums$cowberry_cover2 <- sums$cowberry_cover/14
cow.cov.mc <- MCMCglmm(sqrt(cowberry_cover2) ~ year*N*thin + year*P + Latitud.s, random = ~exp_name + id, 
                   data=sums, family = "gaussian",  nitt = 110000, burnin = 15000,
                   thin=50, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(cow.cov.mc)
summary(cow.cov.mc2)

#plot effect
raw.means <- aggregate(cowberry_cover2 ~ year*thin*N+year*P, sums, mean)
newDat <- raw.means[,1:4] 
newDat$Latitud.s <- 0
X <- model.matrix(formula(cow.cov.mc$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat)
res <- apply(cow.cov.mc$Sol[,1:11],1, function (x) x %*% t(X))

# Sqrt tranformed response so for comparison with billberry model (which is untransformed)
# effect sizes are recalculated on the response scale
# Effects are calculated but taking the difference beyween treatment groups
# while contrasts are kept the same
res_eff1 <- (apply(res, 2, function (x) x[c(3,5,7,9)]^2 - x[1]^2 ))
res_eff2 <- (apply(res, 2, function (x) x[c(4,6,8,10)]^2 - x[2]^2 ))
res <- rbind(res_eff1, res_eff2)[c(1,5,2,6,3,7,4,8),] 
raw.means$eff[1:2] <- 0
raw.means$eff[3:10] <- rowMeans(res)
cis <- t(apply(res, 1, function (x) HPDinterval(as.mcmc(x))))
cis <- rbind(c(0,0),c(0,0), cis)
raw.means <- cbind(raw.means, cis)
colnames(raw.means)[7:8] <- c("lo_95", "up_95")
lat.eff <- summary(bill.cov.mc)$solutions[6,1:3] #latitude effect
names(lat.eff) <- colnames(raw.means)[6:8]
raw.means <- rbind(raw.means, c(raw.means[10,1:5], lat.eff) )
raw.means$vars <- c("control", "control", "Thin-2014", "Thin-2015", "N-2014", "N-2015",
                    "Thin+N-2014", "Thin+N-2015", "Thin+N+P-2014", "Thin+N+P-2015", "latitude")
raw.means[,6:8] <- raw.means[,6:8]


cow.cov.p <- ggplot(raw.means[-c(1:2),], aes(x=vars, y=eff)) + 
  geom_hline(yintercept=0, lty=2, lwd=1, colour="grey50") +
  geom_errorbar(aes(ymin=lo_95, ymax=up_95), 
                lwd=0.7, width=0) +
  geom_point(size=4, pch=21, fill="black") +
  ylim(c(-30, 30)) +
  xlab("") +
  ylab("Absolute change (%)") +
  theme(axis.text.x  = element_text(size=14),
        axis.text.y  = element_text(size=14),
        axis.title = element_text(size=14)) +
  annotate("text", label = "b)", y = -23, x = 9, size = 10) +
  coord_flip()

#### done cowberry

# Merge plots
png("cover_plot.png", width=15, height=30, units="cm", res=300)
grid.arrange(bill.cov.p , cow.cov.p , ncol=1, nrow =2)
dev.off()
ggsave("cover_plot.png", width=15, height=30, units="cm", dpi=300)

#### plot effects for neg bin model with glmer
#plot effect
raw.means <- aggregate(cowberry_cover2 ~ year*thin*N+year*P, sums, mean)
newDat <- raw.means[,1:4] 
newDat$Latitud.s <- 0
X <- model.matrix(formula(cow.cov.nb, fixed.only=TRUE)[-2],
                   newDat)
beta <- fixef(cow.cov.nb) ## fixed-effects coefficients
    V <- vcov(cow.cov.nb)[3:11,3:11]     ## variance-covariance matrix of beta
    pred.se <- sqrt(diag(X[,-c(1:2)] %*% V %*% t(X[,-c(1:2)]))) ## std errors of predictions

res <- as.vector(fixef(cow.cov.nb)[3:11] %*% t(X[,-c(1:2)]))
raw.means$eff <- res
cis <- cbind(res - 2*pred.se, res + 2*pred.se)
raw.means <- cbind(raw.means, cis)
colnames(raw.means)[7:8] <- c("lo_95", "up_95")
lat.eff <- summary(cow.cov.nb)$coefficients[6,1:2] #latitude effect
lat.eff <- c(lat.eff[1], lat.eff[1] - lat.eff[2]*2, lat.eff[1] + lat.eff[2]*2)
names(lat.eff) <- colnames(raw.means)[6:8]
raw.means <- rbind(raw.means, c(raw.means[10,1:5], lat.eff) )
raw.means$vars <- c("control", "control", "Thin-2014", "Thin-2015", "N-2014", "N-2015",
                    "Thin+N-2014", "Thin+N-2015", "Thin+N+P-2014", "Thin+N+P-2015", "latitude")



# PART 5 Fungal infections #### 

# Both plant analyzed with Poisson. Although bilberry may be better to analyze using binomial because
# it represents number of subquandrants infected (ie a proportion). However, better with Possion because results can then be compared with cowberry (they are "true" counts, ie shoots infected).
sums$id <- factor(paste(sums$real_treat,sums$exp_name, sep="_"))

sums$billberry_cover2 <- sums$billberry_cover/14 # calc mean cover
library(MCMCglmm)
B= list(mu = matrix(c(0,0,0,0,0,0,1,0,0,0,0,0),12),V = diag(12)*(10))
prior = list(B=B, R=list(V=1, nu=0.002), 
             G=list(G1=list(V=diag(2), nu=0.002, alpha.mu=c(0,0), alpha.V=diag(2)*1000), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2))) 
diag(prior$B$V)[7]<-1e-9

# offset with cover to account for availabillity
#bill.fu.mc <- MCMCglmm(billberry_fungi  ~ year*N*thin + year*P + Latitud.s + log(billberry_cover2), 
#                       random = ~idh(year):exp_name + id, data=sums, family = "poisson",  
#                       nitt = 80000, burnin = 15000, thin=25, 
#                       pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
sums$quad <- 1400
bill.fu.mc <- MCMCglmm(cbind(billberry_fungi, quad-billberry_fungi)  ~ year*N*thin + year*P + Latitud.s + log(billberry_cover2), 
                       random = ~idh(year):exp_name + id, data=sums, family = "multinomial2",  
                       nitt = 80000, burnin = 15000, thin=25, 
                       pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)

summary(bill.fu.mc) # latitude effect

#plot effect
raw.means <- aggregate(billberry_fungi ~ year*thin*N+year*P, sums, mean)
newDat <- raw.means[,1:4] 
newDat$Latitud.s <- 0
newDat$billberry_cover2 <- 1
X <- model.matrix(formula(bill.fu.mc$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat)
res <- apply(bill.fu.mc$Sol[,3:12],1, function (x) x %*% t(X[,-c(1:2)]))
raw.means$eff <- rowMeans(res)
cis <- t(apply(res, 1, function (x) HPDinterval(as.mcmc(x))))
raw.means <- cbind(raw.means, cis)
colnames(raw.means)[7:8] <- c("lo_95", "up_95")
lat.eff <- summary(bill.fu.mc)$solutions[6,1:3] #latitude effect
names(lat.eff) <- colnames(raw.means)[6:8]
raw.means <- rbind(raw.means, c(raw.means[10,1:5], lat.eff) )
raw.means$vars <- c("control", "control", "Thin-2014", "Thin-2015", "N-2014", "N-2015",
                    "Thin+N-2014", "Thin+N-2015", "Thin+N+P-2014", "Thin+N+P-2015", "latitude")
raw.means[,6:8] <- (exp(raw.means[,6:8]))

library(ggplot2)
bil.fun.p <- ggplot(raw.means[-c(1:2),], aes(x=vars, y=eff)) + 
  geom_hline(yintercept=1, lty=2, lwd=1, colour="grey50") +
  geom_errorbar(aes(ymin=lo_95, ymax=up_95), 
                lwd=0.7, width=0) +
  geom_point(size=4, pch=21, fill="black") +
  ylim(c(0, 6)) +
  xlab("") +
  ylab("Odds ratio") +  # (treatment:control)
  theme(axis.text.x  = element_text(size=14),
        axis.text.y  = element_text(size=14),
        axis.title = element_text(size=14)) +
  annotate("text", label = "a)", y = 0, x = 9, size = 10) +
  coord_flip()

# cowberry
# Number of infected shoots counted Poisson errors are used here. 
sums$cowberry_cover2 <- sums$cowberry_cover/14 # calc mean cover
B= list(mu = matrix(c(0,0,0,0,0,0,1,0,0,0,0,0),12),V = diag(12)*(10))
prior = list(B=B, R=list(V=1, nu=0.002), 
             G=list(G1=list(V=1, nu=0.002, alpha.mu=0, alpha.V=625^2), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2))) 
diag(prior$B$V)[7]<-1e-9

cow.fu.mc <- MCMCglmm(cowberry_fungi  ~ year*N*thin + year*P + Latitud.s + log(cowberry_cover2+0.5), 
                      random = ~exp_name + id, data=sums, family = "poisson",  nitt = 80000, burnin = 15000,
                      thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)

summary(cow.fu.mc) # a latitude effect

#plot effect
raw.means <- aggregate(cowberry_fungi ~ year*thin*N+year*P, sums, mean)
newDat <- raw.means[,1:4] 
newDat$Latitud.s <- 0
newDat$cowberry_cover2 <- 0.5
X <- model.matrix(formula(cow.fu.mc$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat)
res <- apply(cow.fu.mc$Sol[,3:12],1, function (x) x %*% t(X[,-c(1:2)]))
raw.means$eff <- rowMeans(res)
cis <- t(apply(res, 1, function (x) HPDinterval(as.mcmc(x))))
raw.means <- cbind(raw.means, cis)
colnames(raw.means)[7:8] <- c("lo_95", "up_95")
lat.eff <- summary(cow.fu.mc)$solutions[6,1:3] #latitude effect
names(lat.eff) <- colnames(raw.means)[6:8]
raw.means <- rbind(raw.means, c(raw.means[10,1:5], lat.eff) )
raw.means$vars <- c("control", "control", "Thin-2014", "Thin-2015", "N-2014", "N-2015",
                    "Thin+N-2014", "Thin+N-2015", "Thin+N+P-2014", "Thin+N+P-2015", "latitude")
raw.means[,6:8] <- (exp(raw.means[,6:8]))

library(ggplot2)
cow.fun.p <- ggplot(raw.means[-c(1:2),], aes(x=vars, y=eff)) + 
  geom_hline(yintercept=1, lty=2, lwd=1, colour="grey50") +
  geom_errorbar(aes(ymin=lo_95, ymax=up_95), 
                lwd=0.7, width=0) +
  geom_point(size=4, pch=21, fill="black") +
  ylim(c(0, 2)) +
  xlab("") +
  ylab("Rate ratio") +
  theme(axis.text.x  = element_text(size=14),
        axis.text.y  = element_text(size=14),
        axis.title = element_text(size=14)) +
  annotate("text", label = "b)", y = 0, x = 9, size = 10) +
  coord_flip()

# Merge plots
library(gridExtra)
png("fungi_plot.png", width=30, height=15, units="cm", res=300)
grid.arrange(bil.fun.p , cow.fun.p , ncol=2, nrow =1)
dev.off()

##### done fungi


### PART 6 herbivory ####
sums$id <- factor(paste(sums$real_treat,sums$exp_name, sep="_"))
sums$billberry_cover2 <- sums$billberry_cover/14 # calc mean cover
sums$quad <- 1400

library(MCMCglmm)
B= list(mu = matrix(c(0,0,0,0,0,0,1,0,0,0,0,0),12),V = diag(12)*(10))
prior = list(B=B, R=list(V=1, nu=0.002), 
             G=list(G1=list(V=diag(2), nu=0.002, alpha.mu=c(0,0), alpha.V=diag(2)*1000), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2))) 
diag(prior$B$V)[7]<-1e-9

#sums2 <- sums[!(sums$exp_name=="929Nysund"),] #if removed an effect of latitude
bill.he.mc <- MCMCglmm(cbind(billberry_herbivory, quad-billberry_herbivory)  ~ year*N*thin + year*P + Latitud.s 
                       + log(billberry_cover2), 
                       random = ~idh(year):exp_name + id, data=sums, family = "multinomial2",  
                       nitt = 80000, burnin = 15000, thin=25, 
                       pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(bill.he.mc) # A neg N effect on herbivory the first year, nothing else.

sums$cowberry_cover2 <- sums$cowberry_cover/14 # calc mean cover
B= list(mu = matrix(c(0,0,0,0,0,0,1,0,0,0,0,0),12),V = diag(12)*(10))
prior = list(B=B, R=list(V=1, nu=0.002), 
            G=list(G1=list(V=1, nu=0.002, alpha.mu=0, alpha.V=625^2), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2)))
diag(prior$B$V)[7]<-1e-9

cow.he.mc <- MCMCglmm(cbind(cowberry_herbivory, quad-cowberry_herbivory)  ~ year*N*thin + year*P + Latitud.s + 
                        log(cowberry_cover2+0.5), 
                      random = ~exp_name + id, data=sums, family = "multinomial2",  
                      nitt = 80000, burnin = 15000, thin=25, 
                      pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(cow.he.mc) # NO significant effects
######end herbivory




## cor
library(MCMCglmm)
cr <- sums[,c("billberry_fruits", "cowberry_fruits", "billberry_fungi","cowberry_fungi", "billberry_herbivory",
        "cowberry_herbivory","billberry_cover", "cowberry_cover")]
pairs(cr)
round(cor(cr),digits=2)

prior = list(R=list(V=1, nu=0.002), 
            G=list(G1=list(V=diag(2), nu=1.002, alpha.mu=c(0,0), alpha.V=diag(2)*625^2), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2)))

bill.corr.mc <- MCMCglmm(billberry_fruits  ~ billberry_cover + billberry_fungi + thin+N, random = ~idh(year):exp_name + id, data=sums, family = "poisson",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(bill.corr.mc)


prior = list(R=list(V=1, nu=0.002), 
            G=list(G1=list(V=1, nu=0.002, alpha.mu=0, alpha.V=625^2), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2)))

cow.corr.mc <- MCMCglmm(cowberry_fruits  ~ cowberry_cover + cowberry_fungi + thin+N, random = ~ exp_name + id, data=sums, family = "poisson",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(cow.corr.mc)


# SEM ####
#library(devtools)
#install_github("jslefche/piecewiseSEM")
sums <- read.csv("gg_sums.csv")
library(piecewiseSEM)

# SEM mcmc way
library(MCMCglmm)
sums$id <- factor(paste(sums$real_treat,sums$exp_name, sep="_"))
sums$quad <- 1400

# bilberry
sums$billberry_cover2 <- sums$billberry_cover/14
sums$billberry_fungi2 <- sums$billberry_fungi/14
prior = list(R=list(V=1, nu=0.002), 
            G=list(G1=list(V=diag(2), nu=1.002, alpha.mu=c(0,0), alpha.V=diag(2)*625^2), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2)))

bil.cov.mc.sem <- MCMCglmm(billberry_cover2  ~ N + thin + Latitud.s + year, random = ~idh(year):exp_name + id, data=sums, family = "gaussian",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)

bil.fun.mc.sem <- MCMCglmm(cbind(billberry_fungi, quad - billberry_fungi) ~ billberry_cover2 + Latitud.s + N + thin + year, random = ~idh(year):exp_name + id, data=sums, family = "multinomial2",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)

bil.fruit.mc.sem <- MCMCglmm(billberry_fruits  ~ billberry_fungi2 + billberry_cover2 + Latitud.s + N + thin + year, random = ~idh(year):exp_name + id, data=sums, family = "poisson",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)

summary(bil.cov.mc.sem)
summary(bil.fun.mc.sem)
summary(bil.fruit.mc.sem)

#Cowberry
sums$cowberry_cover2 <- sums$cowberry_cover/14
prior = list(R=list(V=1, nu=0.002), 
            G=list(G1=list(V=diag(1), nu=0.002, alpha.mu=c(0), alpha.V=diag(1)*625^2), 
                    G2=list(V=1, nu=0.002,alpha.mu=0, alpha.V=625^2)))
# Random slope not needed
cow.cov.mc.sem <- MCMCglmm(cbind(cowberry_cover, quad-cowberry_cover)  ~ N + thin + Latitud.s + year, random = ~exp_name + id, data=sums, family = "multinomial2",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)

cow.fun.mc.sem <- MCMCglmm(cowberry_fungi  ~ cowberry_cover2 + Latitud.s + N + thin + year, random = ~exp_name + id, data=sums, family = "poisson",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)

cow.fruit.mc.sem <- MCMCglmm(cowberry_fruits  ~ cowberry_fungi + cowberry_cover2 + Latitud.s + N + thin + year, random = ~exp_name + id, data=sums, family = "poisson",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)

summary(cow.cov.mc.sem)
summary(cow.fun.mc.sem)
summary(cow.fruit.mc.sem)

####### End MCMCglmm SEM models

  lmer(cowberry_cover2.sqrt ~  N2+thin2+Latitud.s+year2+(1|exp_name)+(1|id), 
  data = sums), 

  #glmer(cowberry_fungi ~  cowberry_cover2.sqrt+ Latitud.s + N2+thin2 + (1|exp_name)+(1|id)+(1|iid), 
  #data = sums, family=poisson), 
  
  glmer(cowberry_fruits ~  cowberry_cover2.sqrt+ thin2+N2+ Latitud.s+year2+
         (1|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums)




as.vector(apply(mmF$Sol,2,mean) %*% t(mmF$X)))


# alternative with crebile intervals
vmVarF<-numeric(1000)

preds <- 1:4
for(i in 1:1000){
Var<-var(as.vector(bil.cov.mc.sem$Sol[i,preds] %*% t(bil.cov.mc.sem$X)))
vmVarF[i]<-Var}


R2m<-vmVarF/(vmVarF+mmF$VCV[,1]+mmF$VCV[,2]+mmF$VCV[,3])

mean(R2m)

posterior.mode(R2m)

HPDinterval(R2m) 

How can I calculate R2 for an Bayesian MCMC multilevel model? - ResearchGate. Available from: https://www.researchgate.net/post/How_can_I_calculate_R2_for_an_Bayesian_MCMC_multilevel_model [accessed Oct 13, 2016].

 varRand = sum(sapply(VarCorr(model)[n.obs], function(Sigma) {
                X = model.matrix(model)
                # X = model$X
                Z = X[, rownames(Sigma), drop = FALSE]
                #Z = X[, rownames(Sigma), drop = FALSE]
                Z.m = Z %*% Sigma
                sum(diag(crossprod(Z.m, Z)))/nrow(X)
            }))
 


bill.corr.mc <- MCMCglmm(billberry_fruits  ~ billberry_cover*year + billberry_fungi*year + billberry_herbivory*year, random = ~idh(year):exp_name + id, data=sums, family = "poisson",  nitt = 80000, burnin = 15000, thin=25, pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, prior=prior)
summary(bill.corr.mc)

# model list bilberry
library(lme4)
sums$id <- factor(paste(sums$real_treat,sums$exp_name, sep="_"))
sums$iid <- factor(1:nrow(sums))
sums$N2 <- as.numeric(sums$N)
sums$thin2 <- as.numeric(sums$thin)
sums$year2 <- as.numeric(sums$year)
sums$billberry_fruits.log <- log(sums$billberry_fruits+1)
sums$billberry_fungi.sqrt <- sqrt(sums$billberry_fungi)
sums$billberry_cover2 <- sums$billberry_cover/14
sums$quad <- 1400
set.seed(1)
gg.modlist = list(
  glmer(cbind(billberry_cover, quad -billberry_cover)  ~  thin2+year2+(1|exp_name)+(1|id)+(1|iid), 
  data = sums, family=binomial), 

  glmer(cbind(billberry_fungi, quad - billberry_fungi) ~  billberry_cover2+ Latitud.s + N2+thin2 +year2+ (1|exp_name)+(1|id)+(1|iid), 
  data = sums, family=binomial), 
  
  glmer(billberry_fruits ~  scale(billberry_fungi, scale=FALSE) + billberry_cover2+ thin2+N2+year2+
         (year|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums)

  )
#error msg OK, no diff compared to other optimizers and scaling variablers

sem.fit(gg.modlist, data=sums)
#sem.fit(gg.modlist, data=sums, corr.errors = "billberry_cover2~~billberry_fungi")
tt <- sem.coefs(gg.modlist, data=sums,  standardize = "none")
#tt <- sem.coefs(gg.modlist, data=sums,  standardize = "none", corr.errors = "billberry_cover2~~billberry_fungi")
#sem.plot(gg.modlist, data=sums, scaling=20)
sem.plot(coef.table=tt)
sem.model.fits(gg.modlist)

r2list <- list(glmer(billberry_fruits ~  scale(billberry_fungi, scale=FALSE) + billberry_cover2+ thin2+N2+year2+
         (year2|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums), 
   glmer(billberry_fruits ~   billberry_cover2+ thin2+N2+year2+
         (year2|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums),
   glmer(billberry_fruits ~   scale(billberry_fungi, scale=FALSE) + thin2+N2+year2+
         (year2|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums),
   glmer(billberry_fruits ~  scale(billberry_fungi, scale=FALSE) + billberry_cover2+ N2+year2+
         (year2|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums),
   glmer(billberry_fruits ~  scale(billberry_fungi, scale=FALSE) + billberry_cover2+ thin2+year2+
         (year2|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums),
   glmer(billberry_fruits ~  year2+
         (year2|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums))
sem.model.fits(r2list)


# cover explains 60% in bilberry fruit production looking at onlu control plots
mm3 <-  list(glmer(billberry_fruits ~   
                billberry_cover2+ 
         (1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
         data = sums[sums$real_treat == "not_thinned", ]))
sem.model.fits(mm3)

mm2 <-  glmer(billberry_fruits ~  scale(billberry_fungi, scale=T) + 
                billberry_cover2+ thin2+N2+year +
         (year|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),data = sums)
summary(mm2)
rownames(VarCorr(mm2)["exp_name"])

rr <- list(glmer(billberry_fruits ~  scale(billberry_fungi) + scale(billberry_cover2)+ thin+N+year+
         (year|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums),
glmer(billberry_fruits ~  scale(billberry_fungi) + scale(billberry_cover2)+ thin+N+year+
         (1|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums))

summary(rr)

sem.model.fits(rr)

library(lme4)
library(piecewiseSEM)
y <- list()
for (i in 1:10){y[[i]] <- rpois(10, i)}
dat <- data.frame(y= unlist(y), rand = gl(10,30), treat= rep(c("a","b"), each=5, 30))
mod <- glmer(y ~ treat + (treat|rand), data=dat, family=poisson)
summary(mod)
sem.model.fits(mod)

str(dat)
data(sleepstudy)
mods <- list(lmer(Reaction ~ Days + (factor(Days)|Subject), sleepstudy, family=poisson),
lmer(Reaction ~ Days + (1|Subject), sleepstudy, family=poisson))
sem.model.fits(mods)

# model list cowberry
library(lme4)
sums$id <- factor(paste(sums$real_treat,sums$exp_name, sep="_"))
sums$iid <- factor(1:nrow(sums))
sums$N2 <- as.numeric(sums$N)
sums$thin2 <- as.numeric(sums$thin)
sums$year2 <- as.numeric(sums$year)
sums$cowberry_fruits.log <- log(sums$cowberry_fruits+1)
sums$cowberry_fungi.sqrt <- sqrt(sums$cowberry_fungi)
sums$cowberry_cover2 <- sums$cowberry_cover/14
sums$cowberry_cover2.sqrt <- sqrt(sums$cowberry_cover2)
sums$quad <- 1400
set.seed(1)
gg.modlist = list(
  #lmer(cowberry_cover2.sqrt ~  N2+thin2+Latitud.s+year2+(1|exp_name)+(1|id), 
  #data = sums), 
  glmer(cbind(cowberry_cover, quad-cowberry_cover) ~  N2+thin2+Latitud.s+year2+(1|exp_name)+(1|id), 
  data = sums, family=binomial, glmerControl(optimizer="bobyqa")), 

  #glmer(cowberry_fungi ~  cowberry_cover2.sqrt+ Latitud.s + N2+thin2 + (1|exp_name)+(1|id)+(1|iid), 
  #data = sums, family=poisson), 
  
  glmer(cowberry_fruits ~  cowberry_cover+ thin2+N2+ Latitud.s+year2+
         (1|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums)

  )
#error msg OK, no diff compared to other optimizers and scaling variablers

sem.fit(gg.modlist, data=sums)
tt <- sem.coefs(gg.modlist, data=sums,  standardize = "none")
#sem.plot(gg.modlist, data=sums, scaling=20)
sem.plot(coef.table=tt)
sem.model.fits(gg.modlist)

mm2 <-  glmer(cowberry_fruits ~  cowberry_cover2.sqrt+ thin2+N2+ Latitud.s+
         (1|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums)
summary(mm2)

rrC <- glmer(cowberry_fruits ~  scale(cowberry_cover2)+ Latitud.s + thin2+N2+year2+
         (1|exp_name)+(1|id)+(1|iid), family=poisson, glmerControl(optimizer="bobyqa"),
   data = sums)
summary(rrC)

library(ggplot2)
ggplot(sums, aes(x=N, y=cowberry_cover2, group=exp_name) ) +
  geom_point() +
  facet_wrap(~exp_name)
### end corr




# Define groups to predict means for
newDat <- raw.means[,1:4] #unique(sums[,c("year", "thin", "N", "P")])
newDat$Latitud.s <- 0
newDat$billberry_fruits <- 0
newDat$exp_name <- 1:nrow(newDat)
newDat$id <- 1:nrow(newDat)
mc.pred <- predict.MCMCglmm(bill.mc, newdata=newDat,  marginal=NULL, posterior="mean", type="response", level=0.95)
newDat <- cbind(newDat, mc.pred)

c.marg <- mean(modB_pois_cat_fru$Sol[,1] + 0.5*rowSums(modB_pois_cat_fru$VCV)) # treat control, link scale
n.marg <-mean(rowSums(modB_pois_cat_fru$Sol[,1:2]) + 0.5*rowSums(modB_pois_cat_fru$VCV)) # treat N, link scale
t.marg <-mean(rowSums(modB_pois_cat_fru$Sol[,c(1,3)]) + 0.5*rowSums(modB_pois_cat_fru$VCV)) # treat N, link scale
nt.marg <-mean(rowSums(modB_pois_cat_fru$Sol[,c(1:3,5)]) + 0.5*rowSums(modB_pois_cat_fru$VCV)) # treat N, link scale
p.marg <-mean(rowSums(modB_pois_cat_fru$Sol[,c(1,4)]) + 0.5*rowSums(modB_pois_cat_fru$VCV)) # treat N, link scale

raw = mc.mod = exp(c(treat_C=c.marg, treat_N=n.marg, treat_T=t.marg, 
      treat_NT=nt.marg, treat_P=p.marg))
predict(modB_pois_cat_fru, newdata=newDat, marginal=NULL, posterior="mean", type="terms")

raw.means <- aggregate(billberry_fruits ~ year*thin*N+year*P, sums, mean)
X <- model.matrix(formula(modB_pois_cat_fru$Fixed$formula,fixed.only=TRUE)[-2],
                   newDat)
res <- apply(modB_pois_cat_fru$Sol[,1:11],1, function (x) x %*% t(X))
res <- t(res) + 0.5*rowSums(modB_pois_cat_fru$VCV[,2:4])
data.frame(raw = raw.means, pred = exp(colMeans(res)))


sums2 <- cbind(sums, mc.pred)
  unique(sums2[,c("year", "thin", "N", "P")])
#plot model estimates
newDat$treat <- rep(c("control", "N", "thinning", "N+thinning", "N+thinning+P"), each=2)
library(ggplot2)
ggplot(newDat, aes(x=treat, y=fit, fill=year)) + 
    geom_bar(width = 0.75, position=position_dodge(), stat="identity") +
    geom_errorbar(aes(ymin=lwr, ymax=upr),
                  width=.1,                    # Width of the error bars
                  position=position_dodge(.8)) +
  ylab(expression("No of berries per 0.25 m"^2)) +
  xlab("TREATMENTS") +
 ggtitle("Treatment effetcs on billberry productioin")



modB_pois_cat_fru <- MCMCglmm(billberry_fruits ~ year*real_treat+Latitud.s, random = ~us(1+year):exp_name + id, data=sums, family = "poisson",  nitt = 30000, burnin = 5000, pr=TRUE, pl = TRUE)
summary(modB_pois_cat_fru)

library(glmmADMB)
ad.mod <- glmmadmb(billberry_fruits ~ year*real_treat+real_treat*Latitud.s + (1|exp_name) + (1|id), 
                           data=sums, family = "nbinom", zeroInflation=TRUE)
summary(ad.mod)


# sim with mcmcglmm
mc.pred.sim <- simulate.MCMCglmm(cow.mc, nsim=2000,
                             posterior="mean", type="response")
nzeros <- colSums(mc.pred.sim==0)
par(las=1,bty="l")
plot(pt <- prop.table(table(nzeros)),
     ylab="Probability")
(obszero <- sum(sums$cowberry_fruits==0))
points(obszero,0.005,col="red",pch=16,cex=2)
### Average over simulations to get predicted counts
out <- matrix(NA, ncol=3, nrow=651)
cnt <- 0:650

for (i in 1:length(cnt)) {
	out[i,1] <- mean(apply(mc.pred.sim, 2, 
						FUN = function(x) {
							sum(x == cnt[i]) }))
	out[i,2:3] <-quantile(as.numeric(apply(mc.pred.sim, 2, FUN= function (x) sum(x == cnt[i]))), 
	                      prob=c(0.1, 0.9))
}

comp <- data.frame(y.mod=as.matrix(out), x=0:650)
d.raw <- data.frame(y.raw=as.matrix((table(sums$cowberry_fruits))), x=as.numeric(rownames(table(sums$cowberry_fruits))))
comp2 <- merge(comp, d.raw, by="x")
comp2 <- reshape(comp2, direction = "long", varying = list(c(2,5)), times=c("y.mod.1", "y.raw"), v.names = "freq")
library(ggplot2)
ggplot(comp2, aes(x=x, y=freq ,fill=time))+
  geom_bar(stat="identity",position="dodge") +
      geom_errorbar(aes(ymin=y.mod.2, ymax=y.mod.3),
                  width=0, size=0.1, colour= "grey6",                  
                  position=position_dodge(.9))




ranef.mcmc <- colMeans(modB_pois_cat_fru$Liab) - predict(modB_pois_cat_fru, 
marginal = NULL, type = "terms")
hist(ranef.mcmc)
qqnorm(ranef.mcmc) ; qqline(ranef.mcmc)

#glmer model Predictive check
mod.sim <- simulate(modB_pois_cat_fru.b, nsim = 2000)
nzeros <- colSums(mod.sim==0)
par(las=1,bty="l")
plot(pt <- prop.table(table(nzeros)),
     ylab="Probability")
(obszero <- sum(sums$billberry_fruits==0))
points(obszero,0.005,col="red",pch=16,cex=2)

### Average over simulations to get predicted counts
out <- matrix(NA, ncol=3, nrow=651)
cnt <- 0:650

for (i in 1:length(cnt)) {
	out[i,1] <- mean(apply(mod.sim, 2, 
						FUN = function(x) {
							sum(x == cnt[i]) }))
	out[i,2:3] <-quantile(as.numeric(apply(mod.sim, 2, FUN= function (x) sum(x == cnt[i]))), 
	                      prob=c(0.1, 0.9))
}

comp <- data.frame(y.mod=as.matrix(out), x=0:650)
d.raw <- data.frame(y.raw=as.matrix((table(sums$billberry_fruits))), x=as.numeric(rownames(table(sums$billberry_fruits))))
comp2 <- merge(comp, d.raw, by="x")
comp2 <- reshape(comp2, direction = "long", varying = list(c(2,5)), times=c("y.mod.1", "y.raw"), v.names = "freq")
library(ggplot2)
ggplot(comp2, aes(x=x, y=freq ,fill=time))+
  geom_bar(stat="identity",position="dodge") +
      geom_errorbar(aes(ymin=y.mod.2, ymax=y.mod.3),
                  width=0, size=0.1, colour= "grey6",                  
                  position=position_dodge(.9))
# end glmer sim

### not agg data
library(glmmADMB)
ad.mod <- glmmadmb(billberry_fruits ~ year*real_treat+real_treat*Latitud.s + (1|exp_name) + (1|id) + (1|idd), 
                           data=full_dat2, family = "nbinom", verbose=TRUE)
summary(ad.mod)
simulate(ad.mod)


library(MCMCglmm)
modB_pois_cat_fru <- MCMCglmm(billberry_fruits ~ year*real_treat+real_treat*Latitud.s, random = ~exp_name + id + idd, data=full_dat2, family = "poisson",  nitt = 30000, burnin = 5000, pr=TRUE, pl = TRUE)
summary(modB_pois_cat_fru)

mc.pred <- predict.MCMCglmm(modB_pois_cat_fru, posterior="mean")
mc.pred <- predict.MCMCglmm(modB_pois_cat_fru, marginal=NULL, posterior="distribution", type="terms", interval = "prediction")
sum(dpois(0, exp(mc.pred)))

modB_pois_cat_fru2 <- glmer(billberry_fruits ~ year*real_treat+real_treat+Latitud.s + (1|exp_name) + (1|idd) + (1|iddd), 
                           full_dat2, family = poisson,  control=glmerControl(optimizer="nloptwrap",nAGQ=0))
modB_pois_cat_fru.b <- glmer(billberry_fruits ~ year+Latitud.s + (1|exp_name)+ (1|id)+ (1|idd)+ (1|iddd), 
                             full_dat2, family = poisson)
overdisp_fun(modB_pois_cat_fru)
summary(modB_pois_cat_fru2, cor=FALSE)
anova(modB_pois_cat_fru)
plot(modB_pois_cat_fru)
library(nlme)
modB_log_cat <- lme((billberry_fruits+0.1)^0.25 ~ Latitud.s*real_treat + year*real_treat, random= ~ 1|exp_name/id/idd, full_dat2, 
                     control=list(maxIter=200,opt = "optim") )
anova(modB_log_cat)
plot(modB_log_cat)
summary(modB_log_cat)


library(nlme)
# first things some thing.
means$id <- factor(paste(means$exp_name, means$real_treat, sep = "_" ) ) #make id for the repeated measurement structure.
means$year <- factor(means$year) # years as categories
means$Latitud.s <- scale(means$Latitud, scale = FALSE) # centralize latitude so means are given for mean latitude (so mid sweden)

# we can analyse as categorical levels
# we use a power function for the variance to account for the increasing variance with the response
# the prower function cant take zeros it seems so we add 0.1.
modB_log_cat <- lme(billberry_fruits+0.1 ~ Latitud.s + year+real_treat, random= ~ 1|exp_name/id, means, 
                    weights = varPower(form =~fitted(.)) , control=list(maxIter=1000,opt = "optim") )

#alternative ways to analyse the data
# log with +0.1 gives good residuals
#modB_log_cat <- lme(log(billberry_fruits+0.1) ~ factor(year)+real_treat+scale(Latitud), random= ~ 1|exp_name/id, weights = varIdent(form=~1|real_treat), means,control=list(maxIter=1000,opt = "optim") )

# we can treat it as N and thinning. We also have P but we have to remember that P actually is
# N+thin+P
#modB_log_pred <- lme(log(billberry_fruits+0.1) ~ factor(year)+N*thin+P+scale(Latitud), random= ~ 1|exp_name/id, weights = varIdent(form=~1|real_tr#eat), means,control=list(maxIter=1000,opt = "optim") )

# an option is to use ^0.25 as transformation
#modB_log_pred <- lme(billberry_fruits^0.25 ~ factor(year)+N*thin+P+scale(Latitud), random= ~ 1|exp_name/id, weights = varIdent(form=~1|real_treat##), means,control=list(maxIter=1000,opt = "optim") )

#summary(modB_log_cat)
```
ANOVA TABLE (real_treat = the treatment categories)

```{r echo=FALSE} 
anova(modB_log_cat)
```

A residual plot that looks OK.

```{r echo=FALSE} 
plot(modB_log_cat)
```

An effect detected! Well, **P = ```r round(anova(modB_log_cat)$'p-value'[3],4) ```**. The model looks OK but there is no autocorrelation between years which is a little bit weird.  
The effect may be tiny so lets plot the predicted means.

```{r echo=FALSE, results='hide',message=FALSE}
# Define groups to predict means for
newDat <- data.frame("real_treat" = rep(levels(means$real_treat), 2), "year" =rep(levels(means$year), each=length(levels(means$real_treat))),
                  "Latitud.s" = 0)
# Predict means
newDat$means <- predict(modB_log_cat, newDat, level =0)

#create design matrix
Designmat <- model.matrix(eval(eval(modB_log_cat$call$fixed)[-2]), newDat[-ncol(newDat)])

#compute standard error for predictions
predvar <- diag(Designmat %*% modB_log_cat$varFix %*% t(Designmat))
newDat$SE <- sqrt(predvar) 

#plot
library(ggplot2)
ggplot(newDat, aes(x=real_treat, y=means, fill=year)) + 
    geom_bar(width = 0.75, position=position_dodge(), stat="identity") +
    geom_errorbar(aes(ymin=means-SE, ymax=means+SE),
                  width=.1,                    # Width of the error bars
                  position=position_dodge(.8)) +
  ylab(expression("No of berries per 0.25 m"^2)) +
  xlab("TREATMENTS") +
 ggtitle("Treatment effetcs on billberry productioin")

# #code for backtransform log-scale
# For example in 2015, thinning alone increases berry production with **```r round(exp(fixef(modB_log_cat)[1]+fixef(modB_log_cat)[2]+fixef(modB_log_cat)[4]  + 0.5*as.numeric(VarCorr(modB_log_cat)[4,1])) - exp(fixef(modB_log_cat)[1]+fixef(modB_log_cat)[2] + 0.5*as.numeric(VarCorr(modB_log_cat)[4,1])),2)```. Wow! ;)**. 
# In 2014, the thinning effect was **```r round(exp(fixef(modB_log_cat)[1]+fixef(modB_log_cat)[4] + 0.5*as.numeric(VarCorr(modB_log_cat)[4,1])) - exp(fixef(modB_log_cat)[1] + 0.5*as.numeric(VarCorr(modB_log_cat)[4,1])),2)```. Wow! ;)**
# 
# However, N addition has a negative effect on berry production when comparing a thinned stand with a thinned and N fertilized stand: a reduction of 
# **```r round(exp(fixef(modB_log_cat)[1]+fixef(modB_log_cat)[2]+fixef(modB_log_cat)[4]  + 0.5*as.numeric(VarCorr(modB_log_cat)[4,1])) - exp(fixef(modB_log_cat)[1]+fixef(modB_log_cat)[2]+fixef(modB_log_cat)[5] + 0.5*as.numeric(VarCorr(modB_log_cat)[4,1])),2)```.** In 2014, the N effect was **```r round(exp(fixef(modB_log_cat)[1]+fixef(modB_log_cat)[4]  + 0.5*as.numeric(VarCorr(modB_log_cat)[4,1])) - exp(fixef(modB_log_cat)[1]+fixef(modB_log_cat)[5] + 0.5*as.numeric(VarCorr(modB_log_cat)[4,1])),2)```. **

#The correlation coef between two samples, 2014 and 2015, is , r = **```r round(as.numeric(VarCorr(modB_log_cat)[4,1]) / (as.numeric(VarCorr(modB_log_cat)[4,1]) + as.numeric(VarCorr(modB_log_cat)[5,1])), 2)``` **
  
```

What sticks out is the positive effect of thinning on berry production. For example, thinning alone increases berry production with **```r newDat[3,4] - newDat[1,4]```** berries. Wow! ;). However, N addition has a negative effect on berry production. E.g. when comparing a thinned stand with a thinned and N fertilized stand: a reduction of  **```r  newDat[3,4] - newDat[4,4]```** berries.

I DID NOT INCLUDE ANY INTERACTIONS. That is why the year difference is the same for all treatments. THIS GOES FOR ALL PLOTS!!
I did test year*treat here and it does mess thing up a bit. 1) the model freaks out and Im not sure the results are trustworthy. The year*treat interaction is far from significant and weird things seems to happen. However, it seems like the effect was stronger in one year and that the negative N effect was rather weak the other year, especially in the NP treatment. This needs further analyses.........

2015 had on average **```r mean(newDat[1:5,"means"])```** berries.
2014 had on average **```r mean(newDat[6:10,"means"])```** berries. 

On average (pooling over years, sites, plot) a 0.25 m2 plot had ```r round(mean(means$billberry_fruits),2) ``` billberries. As you see, this number is higher than the predicted mean. The lower predicted mean is taking into account the structure of the data and will down weight the extreme high values observed in 2015 (a random effect model will pull extreme towards the middle). If we look at the raw median, then the picture changes a bit ```r round(median(means$billberry_fruits),2)```.

```{r echo=FALSE, results='hide',message=FALSE}
#modB_log_cat_yr <- lme(billberry_fruits+1 ~ year, random= ~ 1|exp_name/id, means, weights = varPower(form =~fitted(.)) , control=list(maxIter=1000,opt = "optim") )
#summary(modB_log_cat_yr)

# modB_log_year <- lme(log(billberry_fruits+0.1) ~ factor(year), random= ~ 1|exp_name/id, means,control=list(maxIter=1000,opt = "optim") )
# modB_log_year <- lm(log(billberry_fruits+0.1) ~ factor(year), means)
# modB_log_year2 <- lm(log(billberry_fruits+0.1) ~ 1, means)
# aggregate((billberry_fruits+0.1)~year, means, median)
# summary(modB_log_year)
# summary(modB_log_year2)
# 
# exp(1.38+(1.32)/2)
# 
# tt <- rlnorm(500, 1.38, 1.32)
# median(tt)
# exp(mean(log(tt))+(1.32^2)/2)
# exp(1.75+0.7/2)
```

##Now cowberry.
Data is messy again and we have a few very high values in 2015. The power variance functions dont work well and I instead tried to model seperate variances for each group x year combination. Seems to work OK and I think the stat tests should be fine. 
```{r}
modC_log_cat <- lme(cowberry_fruits ~ year*real_treat, random= ~ 1|exp_name/id, means, weights = varIdent(form=~1|real_treat*year) , control=list(maxIter=1000,opt = "optim") )
#summary(modC_log_cat)
```

ANOVA TABLE (real_treat = the treatment categories)

```{r echo=FALSE} 
anova(modC_log_cat)
```

A residual plot that looks quite OK.

```{r echo=FALSE} 
plot(modC_log_cat)
```

An effect detected! **P = ```r round(anova(modC_log_cat)$'p-value'[3],4) ```**. 

```{r echo=FALSE, results='hide',message=FALSE}
# Define groups to predict means for
newDat <- data.frame("real_treat" = rep(levels(means$real_treat), 2), "year" =rep(levels(means$year), each=length(levels(means$real_treat))),
                  "Latitud.s" = 0)
# Predict means
newDat$means <- predict(modC_log_cat, newDat, level =0)

#create design matrix
Designmat <- model.matrix(eval(eval(modC_log_cat$call$fixed)[-2]), newDat[-ncol(newDat)])

#compute standard error for predictions
predvar <- diag(Designmat %*% modC_log_cat$varFix %*% t(Designmat))
newDat$SE <- sqrt(predvar) 

#plot
library(ggplot2)
ggplot(newDat, aes(x=real_treat, y=means, fill=year)) + 
    geom_bar(width = 0.75, position=position_dodge(), stat="identity") +
    geom_errorbar(aes(ymin=means-SE, ymax=means+SE),
                  width=.1,                    # Width of the error bars
                  position=position_dodge(.8)) +
  ylab(expression("No of berries per 0.25 m"^2)) +
  xlab("TREATMENTS") +
 ggtitle("Treatment effetcs on cowberry productioin")
```

What sticks out is the positive effect of thinning on berry production. For example, thinning alone increases berry production with **```r newDat[3,4] - newDat[1,4]```** berries. Wow! ;). However, N addition has a negative effect on berry production when comparing a thinned stand with a thinned and N fertilized stand: a reduction of  **```r  newDat[3,4] - newDat[4,4]```** berries.

I testsed the year*treat interaction which was highly significant here. BUT the effect is not super important I would say. THe difference between the years are mainly between not_thinned vs not_thinned+N. In 2015 the variation in thinning and thinnin+N is much higher and these two treatments have quite an overlap.....effect size not much different from 2014 though.

2015 had on average **```r mean(newDat[1:5,"means"])```** cowberries.
2014 had on average **```r mean(newDat[6:10,"means"])```** cowberries. 

On average (pooling over years, sites, plot) a 0.25 m2 plot had ```r round(mean(means$cowberry_fruits),2) ``` cowberries. If we look at the raw median, then the picture changes a bit ```r round(median(means$cowberry_fruits),2)```. See discussion above regarding model predicted means vs raw means.

##Cover
We can plot the results for each site.

```{r,echo = FALSE,fig.width=14, fig.height=10}
library(lattice)
xyplot(billberry_cover ~ real_treat|exp_name, groups = year, means, main ="Billberry",type = c("p","l"), auto=TRUE, xlab="",
       scales=list( x=list(labels = c("No \nthin", "No \nthin+N", "thin","thin+\nN","thin+\nNP"))))
xyplot(cowberry_cover ~ real_treat|exp_name, groups = year, means, main ="Cowberry",type = c("p","l"), auto=TRUE, xlab="",
       scales=list( x=list(labels = c("No \nthin", "No \nthin+N", "thin","thin+\nN","thin+\nNP"))))
```

```{r}
ggplot(means, aes(x = billberry_cover, y=billberry_fruits)) +
  geom_point() + scale_y_log10()  + ylab(expression("Billberry fruits per 0.25 m"^-2)) +
  xlab("Billberry cover (%)")
ggplot(means, aes(x = cowberry_cover, y=cowberry_fruits)) +
  geom_point() + scale_y_log10() + ylab(expression("Cowberry fruits per 0.25 m"^-2)) +
  xlab("Cowberry cover (%)")
  
```

Didnt dig deeper into this..........

##Fungus

```{r,echo = FALSE,fig.width=14, fig.height=10}
library(lattice)
xyplot(billberry_fungi ~ real_treat|exp_name, groups = year, means, main ="Billberry",type = c("p","l"), auto=TRUE, xlab="",
       scales=list( x=list(labels = c("No \nthin", "No \nthin+N", "thin","thin+\nN","thin+\nNP"))))
xyplot(cowberry_fungi ~ real_treat|exp_name, groups = year, means, main ="Cowberry",type = c("p","l"), auto=TRUE, xlab="",
       scales=list( x=list(labels = c("No \nthin", "No \nthin+N", "thin","thin+\nN","thin+\nNP"))))
```

#Billberry
Lots of zeros and low values so I tried with a poisson distribution as well.

```{r echo=FALSE, results='hide',message=FALSE}
#modC_fun_cat <- lme(billberry_fungi+0.1 ~ year+real_treat+Latitud.s, random= ~ 1|exp_name/id, means,   weights = varPower(form =~fitted(.)) ,control=list(maxIter=1000,opt = "optim") )
library(lme4)
modB_pois_cat <- glmer(as.integer(billberry_fungi) ~ year+real_treat+Latitud.s + (1|exp_name/id), means, family = poisson)
modB_pois_cat.b <- glmer(as.integer(billberry_fungi) ~ year+Latitud.s + (1|exp_name/id), means, family = poisson)
modB_pois_cat.c <- glmer(as.integer(billberry_fungi) ~ real_treat+Latitud.s + (1|exp_name/id), means, family = poisson)
#summary(modB_pois_cat)
overdisp_fun(modB_pois_cat)
```

A treatment effect detected! **LRT = ```r anova(modB_pois_cat, modB_pois_cat.b)$Chisq[2]```, P = ```r anova(modB_pois_cat, modB_pois_cat.b)$'Pr(>Chisq)'[2]```**. And year as well, **LRT = ```r summary(modB_pois_cat)$coefficients[2,3]^2```, P = ```r summary(modB_pois_cat)$coefficients[2,4]```. There is no effect of latitude, P= ```r summary(modB_pois_cat)$coefficients[7,4]```.  

Now lets plot this.

```{r echo=FALSE, results='hide',message=FALSE}
# Define groups to predict means for
newDat <- data.frame("real_treat" = rep(levels(means$real_treat), 2), "year" =rep(levels(means$year), each=length(levels(means$real_treat))),
                  "Latitud.s" = 0)
# Predict means
newDat$means <- predict(modB_pois_cat, newDat, re.form=NA, type = "response")
seLim <- easyPredCI(modB_pois_cat, newDat[,-ncol(newDat)])
newDat <- cbind(newDat,seLim)

#plot
library(ggplot2)
ggplot(newDat, aes(x=real_treat, y=means, fill=year)) + 
    geom_bar(width = 0.75, position=position_dodge(), stat="identity") +
    geom_errorbar(aes(ymin=lwr, ymax=upr),
                  width=.1,                    # Width of the error bars
                  position=position_dodge(.8)) +
  ylab(expression("No of infections per 0.25 m"^-2)) +
  xlab("TREATMENTS") +
 ggtitle("Treatment effetcs on fungus infection in billberry")
```

Pretty clear effect of nitrogen! We havent taken plant cover into account (e.g. normalize with percent cover) but that will only make the N effect stronger since N treatments have lower plant cover.
Note that these SEs are a bit anti-conservative.

The year*treatment effect had no relevance at all here.

#Cowberry

```{r echo=FALSE, results='hide',message=FALSE}
full_dat$thin <- ifelse(grepl("thinning", full_dat$real_treat), "thin", "no_thin")
full_dat$N <- ifelse(grepl("N", full_dat$real_treat), "Nxtra", "no_N")
full_dat$P <- ifelse(grepl("P", full_dat$real_treat), "Pxtra", "no_P")
full_dat$id <- factor(paste(full_dat$exp_name, full_dat$real_treat, sep = "_" ) ) #make id for the repeated measurement structure.
full_dat$idd <- factor(paste(full_dat$year, full_dat$exp_name, full_dat$real_treat, sep = "_" ) ) #make id for the repeated measurement structure.
full_dat$iddd <- factor(1:nrow(full_dat))
full_dat$year <- factor(full_dat$year) # years as categories
full_dat$Latitud.s <- scale(full_dat$Latitud, scale = FALSE) # centralize latitude so means are given for mean latitude (so mid sweden)

#Grang채rde has a different treatment: Severe thinning + N. We remove it for to keep it simple.
full_dat2 <- full_dat[!(full_dat$real_treat == "severe_thinning+N"),]
full_dat2 <- droplevels(full_dat2)

# TEST med mcmcglmm which confirms glmer results
#library(MCMCglmm)
#prior<-list(G = list(G1 = list(V = diag(1), nu = 0.002), G2 = list(V = diag(1), nu = 0.002),
#                     G3 = list(V = diag(1), nu = 0.002)))
#mm <- MCMCglmm(cowberry_fungi ~ year+real_treat+Latitud.s,
#               random = ~exp_name + id + idd, data = full_dat,   
#              family = "poisson", nitt = 130000, thin = 10, burnin = 3000,pl = TRUE)
#summary(mm)

modC_pois_cat <- glmer(cowberry_fungi ~ year+real_treat+Latitud.s + (1|exp_name)+ (1|id)+ (1|idd)+ (1|iddd), full_dat2, family = poisson)
modC_pois_cat.b <- glmer(cowberry_fungi ~ year+Latitud.s + (1|exp_name)+ (1|id)+ (1|idd)+ (1|iddd), full_dat2, family = poisson)

#summary(modC_pois_cat, cor=FALSE)

#lets go with log for now
#library(lme4)
#modC_fun_cat <- lmer(log(cowberry_fungi+0.1) ~ year+real_treat+Latitud.s + (1|exp_name/id), means)
#summary(modC_fun_cat)

#modC_fun_cat <- lme(cowberry_fungi+0.1 ~ year+real_treat+Latitud.s, random= ~ 1|exp_name/id, means,   weights = varPower(form =~fitted(.)) ,control=list(maxIter=1000,opt = "optim") )

#library(lme4)
#modC_pois_cat <- glmer(cowberry_fungi ~ year+real_treat+Latitud.s + (1|exp_name/id), means, family = poisson)
#modC_pois_cat.b <- glmer(as.integer(cowberry_fungi) ~ year+Latitud.s + (1|exp_name/id), means, family = poisson)
#modC_pois_cat.c <- glmer(as.integer(cowberry_fungi) ~ real_treat+Latitud.s + (1|exp_name/id), means, family = poisson)
#summary(modC_pois_cat2)
#overdisp_fun(modC_pois_cat2) #underdispersion, so P-values are conservative

#summary(modC_log_cat)
```

There is a treatment effect **LRT = ```r anova(modC_pois_cat, modC_pois_cat.b)$Chisq[2]```, P = ```r anova(modC_pois_cat, modC_pois_cat.b)$'Pr(>Chisq)'[2]```** but somewhat weird and mainly driven by no_thinned + N (which we have very few data points for). But NO year effect for cowberry. There is, in contrast to billberry, an effect of latitude, infection incidence increases with ~ ```r round(exp(fixef(modC_pois_cat)[7])-1,2)*100``` % per degree north.

Now lets plot this.

```{r echo=FALSE, results='hide',message=FALSE}
# Define groups to predict means for
newDat <- data.frame("real_treat" = rep(levels(means$real_treat), 2), "year" =rep(levels(means$year), each=length(levels(means$real_treat))),
                  "Latitud.s" = 0)
# Predict means
#newDat$means <- predict(modC_pois_cat, newDat,re.form=NA)
newDat$means <- predict(modC_pois_cat, newDat,re.form=NA, type = "response")
seLim <- easyPredCI(modC_pois_cat, newDat[,-ncol(newDat)])
newDat <- cbind(newDat,seLim)

# #boot CI
# predFun <- function(fit) {
#     predict(fit,newDat[,-ncol(newDat)], re.form=NA)
# }
# bb<-bootMer(modC_pois_cat,FUN=predFun,nsim=2)
# bb <- bootMer(modC_pois_cat, nsim=2, FUN=predFun,seed=101, use.u=TRUE, .progress="txt")

#plot
library(ggplot2)
ggplot(newDat, aes(x=real_treat, y=means, fill=year)) + 
    geom_bar(width = 0.75, position=position_dodge(), stat="identity") +
    geom_errorbar(aes(ymin=lwr, ymax=upr),
                  width=.1,                    # Width of the error bars
                  position=position_dodge(.8)) +

  ylab(expression("No of infections per 0.25 m"^-2)) +
  xlab("TREATMENTS") +
 ggtitle("Treatment effetcs on fungus infection in cowberry")

# Relationship cover and infection rate
ggplot(means, aes(y=as.integer(billberry_fungi), x=cowberry_cover,means)) +
  geom_point() + ylab(expression("No of infections per 0.25 m"^-2)) + xlab("Cover billberry (%)")+
 ggtitle("Correlation between fungus infection and billberry cover")

ggplot(means, aes(y=as.integer(cowberry_fungi), x=cowberry_cover,means)) +
  geom_point() + ylab(expression("No of infections per 0.25 m"^-2)) + xlab("Cover cowberry (%)")+
 ggtitle("Correlation between fungus infection and cowberry cover")

```

An effect of thinning alone. There is a weird nitrogen effect in absence of thinning. Small sample size here so I a bit uncertain. We havent taken plant cover into account (e.g. normalize with percent cover) and that may play a role here.
Note that these SEs are a bit anti-conservative.

The year*treatment effect had no relevance at all here.

##Conclusion
Thinning has a positive effect on berry production and nitrogen a negative. Nitrogen increases fungi infection in billberry but not cowberry. Thinning increases infection in cowberry and infection rate increases with latitude.

```{r echo=FALSE, results='hide',message=FALSE}
## fit model

sleepstudy$Reaction <- as.integer(sleepstudy$Reaction)
sleepstudy$id <- 1:nrow(sleepstudy)
sleepstudy$treat <- rep(c("a", "b"), each=90)
fm1 <- glmer(Reaction ~ treat + (1 | Subject) + (1|id), sleepstudy, family = "poisson")
summary(fm1)
newdat <- data.frame(treat=c("a","b"))
## standard population-level prediction
pframe <- data.frame(newdat, pred=predict(fm1, newdata=newdat, re.form=NA, type = "response"))
newdat$id <- c(1:2)
sims <- matrix(NA, ncol=2, nrow=1000)
for (i in 1:1000) {
  sims[i,] <- simulate(fm1, newdata=newdat,re.form=~0,
             allow.new.levels=TRUE)[[1]]
}
colMeans(sims)
aggregate(Reaction~treat, sleepstudy, mean)


mc.mod <- MCMCglmm(Reaction ~ treat, random =~ Subject, data = sleepstudy, family = "poisson", pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE)
summary(mc.mod)
newdat$Reaction <- 0
newdat$Subject <- 1:2
mc.pred <- predict.MCMCglmm(mc.mod, newdata=newdat,  marginal=~Subject, 
                            posterior="mean", type="response")




# 	Data Generation - 
###############
set.seed(1)
#Random Intercept Hyperparams 
intercept.od<--0.5
intercept.od.sd<-0.5
n.pops.od<-10
n.ind.od<-50
popid.od<-gl(n.pops.od,n.ind.od )

#Slope Vector
treat.slope.od<-0.25

###### Number of simulations
nsim2<-100

#Range of Overdispersion Values
epsvals<- 0.75

########	Set up empty vectors and frames for data
naive.intercept.mean<-od.intercept.mean<-naive.slope<-od.slope<-naive.intercept.se <-od.intercept.se<-olre.se<-VarF.naive.od<-VarF.od.od<-VarDenom.naive.random.od<-VarDenom.od.random.od<-VarDenom.naive.residual.od<-VarDenom.od.residual.od<-naive.slopeerror.eps<-naive.intercepterror.eps<-od.slopeerror.eps<-od.intercepterror.eps<-matrix(nrow=length(epsvals),ncol=nsim2)


############
# Loop Start
############


	for (j in 1:nsim2){

		#Treat Covariates
			treat <- rep(c("a", "b"), 10, each=25)#rnorm(length(popid.od),30,4)
			
			#Data
			data2<-data.frame(popid.od, treat, obs=factor(1:(n.pops.od*n.ind.od)))
			data2$off<-simulate(~treat+(1|popid.od)+ (1|obs),newdata=data2,newparams=list(theta=c(epsvals,intercept.od.sd),beta=c(intercept.od,treat.slope.od)),family=poisson)[[1]]
m.glmer <- glmer(off ~ treat+(1|popid.od)+(1|obs),family=poisson,data=data2)
	}
summary(m.glmer)
exp(fixef(m.glmer)[1]+fixef(m.glmer)[2] + 0.5*(VarCorr(m.glmer)$obs[1]+VarCorr(m.glmer)$popid.od[1])) #BEST!

set.seed(1)
newdat <- data.frame(treat=c("a", "b"), obs=c(1000,2000), popid.od = c(1000,2000))
# Predict population means
predict(m.glmer, newdata=newdat, re.form=NA, type="response")

# Low predictions if compared to raw means
aggregate(off ~ treat, data2, mean)

# Now condition on all random effects
data2$ss <- predict(m.glmer, re.form=~(1|popid.od) + (1|obs), type="response", allow.new.levels=TRUE) 
aggregate(dd ~ treat, data2, mean)

data2$dd 
ee <- simulate(m.glmer ,re.form=NA,  allow.new.levels=TRUE, nsim=1000)
ww <- lapply(ee, FUN= function (x) c(mean(x[1:90]), mean(x[91:180])))
rowMeans(as.data.frame(ww))          

sfun1 <- function(x) {
    simulate(x,newdata=newdat,re.form=~0,
             allow.new.levels=TRUE)[[1]]
}
sfun2 <- function(x) {
    simulate(x,newdata=newdat,re.form=~0, cond.sim=FALSE,
             allow.new.levels=TRUE)[[1]]
}

b2 <- bootMer(m.glmer, FUN=sfun2, nsim=1000, seed=101)
colMeans(b1$t)

sims <- matrix(NA, ncol=2, nrow=2000)
for (i in 1:2000) {
  sims[i,] <- simulate(m.glmer, newdata=newdat, re.form=NA,
             allow.new.levels=TRUE)[[1]]
}
colMeans(sims)
quantile(sims[,2],c(0.025,0.975))

m.mc <- MCMCglmm(off ~ treat, random= ~ popid.od, data=data2, family = "poisson",  
                  pr = TRUE, pl = TRUE, saveX = TRUE,  saveZ = TRUE, nitt = 25000)
summary(m.mc)
newdat$off <- 0
predict(m.mc, newdata=newdat, marginal=NULL, posterior="mean", type="response")
predict(m.mc, marginal=~units, posterior="mean", type="response")

predict(m.mc, newdata=newdat, marginal=NULL, posterior="all", type="response", interval = "confidence")
mean(exp(m.mc$Sol[,1]+m.mc$Sol[,2] + 0.5*rowSums(m.mc$VCV)))
mean(exp(m.mc$Sol[,1] + 0.5*m.mc$VCV[,2]))
    
aggregate(off ~ treat, data2, mean)
```